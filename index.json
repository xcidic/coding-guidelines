[
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/",
	"title": "Angular 1 Style Guide",
	"tags": [],
	"description": "",
	"content": " Angular Team Endorsed Special thanks to Igor Minar, lead on the Angular team, for reviewing, contributing feedback, and entrusting me to shepherd this guide.\nPurpose Opinionated Angular style guide for teams by @john_papa\nIf you are looking for an opinionated style guide for syntax, conventions, and structuring Angular applications, then step right in. These styles are based on my development experience with Angular, presentations, Pluralsight training courses and working in teams.\nThe purpose of this style guide is to provide guidance on building Angular applications by showing the conventions I use and, more importantly, why I choose them.\n If you like this guide, check out my Angular Patterns: Clean Code course at Pluralsight which is a companion to this guide.\n \nCommunity Awesomeness and Credit Never work in a vacuum. I find that the Angular community is an incredible group who are passionate about sharing experiences. As such, Angular expert Todd Motto and I have collaborated on many styles and conventions. We agree on most, and some we diverge. I encourage you to check out Todd\u0026rsquo;s guidelines to get a sense for his approach and how it compares.\nMany of my styles have been from the many pair programming sessions Ward Bell and I have had. My friend Ward has certainly helped influence the ultimate evolution of this guide.\nSee the Styles in a Sample App While this guide explains the what, why and how, I find it helpful to see them in practice. This guide is accompanied by a sample application that follows these styles and patterns. You can find the sample application (named modular) here in the modular folder. Feel free to grab it, clone it, or fork it. Instructions on running it are in its readme.\nTranslations Translations of this Angular style guide are maintained by the community and can be found here.\nTable of Contents  Single Responsibility IIFE Modules Controllers Services Factories Data Services Directives Resolving Promises Manual Annotating for Dependency Injection Minification and Annotation Exception Handling Naming Application Structure LIFT Principle Application Structure Modularity Startup Logic Angular $ Wrapper Services Testing Animations Comments JSHint JSCS Constants File Templates and Snippets Yeoman Generator Routing Task Automation Filters Angular Docs  "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/meanjs/nodejs/",
	"title": "NodeJS Style Guide",
	"tags": [],
	"description": "",
	"content": " Node.JS: Style and structure Additional JavaScript style guides  Felix\u0026rsquo;s Node.js Style Guide Crockford\u0026rsquo;s Code Conventions for the JavaScript Programming Language Or, for something a little more unconventional: NPM\u0026rsquo;s Coding Style Define in this docs  Table of Contents  Avoid this and new More, smaller functions Consistently asynchronous APIs Always check for errors in callbacks Return on callbacks Only throw in synchronous functions Catch errors in sync calls Stick to the callback convention Wrap up  Avoid this and new This may seem like quibbling over coding style, but in Node.js it\u0026rsquo;s an important way of keeping your functions easily composable and reusable.\nBecause Node.js involves passing around many callbacks and using a lot of higher-level functions to manage control flow; you should make sure functions are easy to move around without having to bind to a specific context. Prefer closures over object methods, and prefer explicit arguments over closures.\n// contrived example using prototypes and 'this' function DB(url) { this.url = url; } DB.prototype.info = function (callback) { http.get(this.url + '/info', callback); }; async.parallel([ function (cb) { new DB('http://foo').info(cb); }, function (cb) { new DB('http://bar').info(cb); } ], ...); // similar example using closures function DB(url) { return { info: async.apply(http.get, url + '/info') }; } async.parallel([ DB('http://foo').info, DB('http://bar').info ], ...); // making all arguments explicit var dbInfo = function (url, callback) { http.get(url + '/info', callback); }; async.map(['http://foo', 'http://bar'], dbInfo, ...);  The final style, with all arguments made explicit, allows us to easily pass in an arbitrary list of URLs and perform the same operation on them all. Using a more functional style will make your life significantly easier when it comes to combining functionality in this way.\nOf course, there are cases where making all arguments explicit would be undesirable, and cases where using constructors and prototypes are more efficient. I simply recommend you prefer the latter styles over the former and justify your use of these features when necessary.\nMore, smaller functions Before you even start looking into control flow libraries like async, you can tame much of the \u0026ldquo;callback hell\u0026rdquo; by simply breaking up your functions into smaller components.\n// a deeply-nested function including four asynchronous operations function convertJsonToCsv(filename, target, callback) { readFile(filename, function (err, content) { if (err) { return callback(err); } parseJson(content, function (err, data) { if (err) { return callback(err); } convertToCsv(data, function (err, csv) { if (err) { return callback(err); } writeFile(target, csv, callback); }); }); }); } // the same functionality broken into smaller parts function convertJsonToCsv(filename, target, callback) { readJsonFile(filename, function (err, data) { if (err) { return callback(err); } writeCsvFile(target, data, callback); }); } function readJsonFile(filename, callback) { readFile(filename, function (err, content) { if (err) { return callback(err); } parseJson(content, callback); }); } function writeCsvFile(target, data, callback) { convertToCsv(data, function (err, csv) { if (err) { return callback(err); } writeFile(target, csv, callback); }); }  I\u0026rsquo;d recommend you try and keep your functions down to two asynchronous operations at a time, as in the above example, or to one iteration over a list (using async.map or similar). Having more, smaller functions also makes it easier to recombine them in new ways later on.\nOf course, you can further clean up your code using an asynchronous control flow library. But this is the first step in getting things readable again.\nConsistently asynchronous APIs In order to keep your code predictable, a function should be either always asynchronous, or always synchronous. Consider the following:\nvar CACHE = {}; function getRecord(id, callback) { if (CACHE[id]) { return CACHE[id]; } http.get('http://foo/' + id, callback); }  When someone attempts to use this function, it\u0026rsquo;s very easy to miss out the cached case and have code that never completes:\nfunction getMyRecord(user, callback) { getRecord('record-' + user.id, callback); }  The first time you call getMyRecord it will complete successfully, the second time it will never call the callback (because getRecord returns immediately with the cached result). This might halt execution of the request.\nAnother concern with the getRecord function is execution order:\nfunction getMyRecord(user, callback) { var r = getRecord('record-' + user.id, function (err, record) { if (record) { record.got = true; } return callback(err, record); }); if (r) { r.got = true; } return r; }  Code like this is just too difficult to reason about. In order to implement it reliably you\u0026rsquo;d have to duplicate code inside the getRecord callback, and after it (in case it\u0026rsquo;s synchronous). You then have to do the same thing any time you call the getMyRecord function too. This very quickly becomes messy and confusing.\nThe correct way to handle this is to use process.nextTick to make getRecord asynchronous even when returning a cached result:\nvar CACHE = {}; function getRecord(id, callback) { if (CACHE[id]) { return process.nextTick(function () { return callback(null, CACHE[id]); }); } http.get('http://foo/' + id, callback); }  Now we need only consider the asynchronous case and our code becomes much more predictable.\nAlways check for errors in callbacks Missing an error check inside a callback is a common cause of confusion in debugging. The problem is that the program execution will continue and the failure may manifest itself elsewhere in the code and give you a different error message. You then have to trace it back to the original location.\nFailing to explicitly check for errors inside a callback should be considered a bug. I highly recommend you build this step into your code review process because it can be so easy to miss.\n// wrong! function writeCsvFile(target, data, callback) { convertToCsv(data, function (err, csv) { writeFile(target, csv, callback); }); } // right function writeCsvFile(target, data, callback) { convertToCsv(data, function (err, csv) { if (err) { return callback(err); } writeFile(target, csv, callback); }); }  If you want to reduce the extra code, you can do a one-line if statement when checking for the error: if (err) return callback(err);. Whichever style you choose, I recommend you are consistent, because this piece of code should be easy to spot and easy to notice when it\u0026rsquo;s missing.\nReturn on callbacks Usually, you call a callback as the last thing you do inside a function. You might consider it synonymous with return, only JavaScript does not halt function execution when it hits it. It can be easy to accidentally let execution continue after calling a callback, when you really expected it to end. In order to make this easy to spot, and make sure execution stops in the way you expect, I recommend returning the callback function call.\n// wrong! function writeCsvFile(target, data, callback) { convertToCsv(data, function (err, csv) { if (err) { callback(err); // oops! no return } // this line gets called even when theres an error writeFile(target, csv, callback); }); } // right function writeCsvFile(target, data, callback) { convertToCsv(data, function (err, csv) { if (err) { return callback(err); // execution stops here } writeFile(target, csv, callback); }); }  Only throw in synchronous functions Unfortunately, you can\u0026rsquo;t use try-catch blocks around asynchronous code. That means any exceptions you throw will not be caught and bubble up to the top. This can kill your entire server process if you don\u0026rsquo;t have an uncaughtException handler set up. Even in cases where you do, the error probably no longer has any meaningful context and you can\u0026rsquo;t appropriately respond to a http request, for example.\nAlways, always, always pass errors back to the callback in asynchronous functions. As long as you\u0026rsquo;re following the \u0026ldquo;Always check for errors in callbacks\u0026rdquo; rule the errors will be handled in the appropriate place.\n// wrong! function getRecord(id, callback) { http.get('http://foo/' + id, function (err, doc) { if (err) { return callback(err); } if (doc.deleted) { // this will not get caught by the function calling getRecord throw new Error('Record has been deleted'); } return callback(null, doc); }); } // right function getRecord(id, callback) { http.get('http://foo/' + id, function (err, doc) { if (err) { return callback(err); } if (doc.deleted) { return callback(new Error('Record has been deleted')); } return callback(null, doc); }); }  Catch errors in sync calls This is essentially the same as the previous rule. If you\u0026rsquo;re calling a synchronous function that might throw an exception, inside your asynchronous code, then calling your asynchronous code might also result in an exception.\nFor example:\n// wrong! function readJson(filename, callback) { fs.readFile(filename, function (err, content) { if (err) { return callback(err); } // uh-oh! this line might throw an exception if the content // is not valid JSON var data = JSON.parse(content.toString()); return callback(null, data); }); } // right function readJson(filename, callback) { fs.readFile(filename, function (err, content) { if (err) { return callback(err); } try { var data = JSON.parse(content.toString()); } catch (e) { return callback(e); } return callback(null, data); }); }  Stick to the callback convention There is a vocal minority on the Node.js mailing list and elsewhere which promotes the use of other strategies for handling asynchronous code. Some of them even providing \u0026ldquo;blocking-style\u0026rdquo; APIs. While they are interesting, and you might happily use promises or fibers inside your team, please consider sticking to the Node-style callbacks; where the callback is the last argument to an async function and the first argument to the callback is an error (if one occurred).\nThe vast majority of Node developers follow this style, there is consensus on this. If you expect Node developers outside of your team to use your modules then you\u0026rsquo;ll have a much easier time sticking to convention.\nWrap up While most of this is probably common-sense, I hope some of you find these rules useful. Feedback, argument, and further tips are encouraged in the comments.\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/basic-rules/",
	"title": "Basic Rules",
	"tags": [],
	"description": "",
	"content": " Basic Rules  Only include one React component per file.  However, multiple Stateless, or Pure, Components are allowed per file. eslint: react/no-multi-comp.  Always use JSX syntax. Do not use React.createElement unless you\u0026rsquo;re initializing the app from a file that is not JSX.  "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/single-responsibility/",
	"title": "Single Responsibility",
	"tags": [],
	"description": "",
	"content": " Single Responsibility Rule of 1 [Style Y001]  Define 1 component per file, recommended to be less than 400 lines of code.  Why?: One component per file promotes easier unit testing and mocking.\nWhy?: One component per file makes it far easier to read, maintain, and avoid collisions with teams in source control.\nWhy?: One component per file avoids hidden bugs that often arise when combining components in a file where they may share variables, create unwanted closures, or unwanted coupling with dependencies.\nThe following example defines the app module and its dependencies, defines a controller, and defines a factory all in the same file.\n/* avoid */ angular .module('app', ['ngRoute']) .controller('SomeController', SomeController) .factory('someFactory', someFactory); function SomeController() { } function someFactory() { }  The same components are now separated into their own files.\n/* recommended */ // app.module.js angular .module('app', ['ngRoute']);  /* recommended */ // some.controller.js angular .module('app') .controller('SomeController', SomeController); function SomeController() { }  /* recommended */ // some.factory.js angular .module('app') .factory('someFactory', someFactory); function someFactory() { }  Back to Table of Contents\nSmall Functions [Style Y002]  Define small functions, no more than 75 LOC (less is better).  Why?: Small functions are easier to test, especially when they do one thing and serve one purpose.\nWhy?: Small functions promote reuse.\nWhy?: Small functions are easier to read.\nWhy?: Small functions are easier to maintain.\nWhy?: Small functions help avoid hidden bugs that come with large functions that share variables with external scope, create unwanted closures, or unwanted coupling with dependencies.\nBack to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/meanjs/file-organization/",
	"title": "File Organization",
	"tags": [],
	"description": "",
	"content": " File Organization Please do remember the the project name is using prefix project_. And if the project name is more than one word use _ to separate the name, ex: project_bla_bla, project_abc. Always build a master css file which include styles for every modules. Always build a module-specific css file for styles only used in said module.\n Deliverables  Please remove legacy files, be certain the work is delivered in a clean file system, and in an orderly, logical structure that serves a clear purpose.\n Folder Structure  For every module will use this kind of folder structure. Module name will use lower case. If the module name consist more than one word, use ‘-’ to separate for each word.\nNormal module will consist of these folder:  client - Front end related files, consist of\n config\nThis folder is used to put menu config and routing states.\n controllers\nThis folder is used to put all the controller. Please separate controllers between views.\n css\nThis folder is used to put css for this module if there is any. This folder is optional.\n directives\nThis folder is used to put directives for this module if there is any. This folder is optional.\n img\nThis folder is used to put images for this module if there is any. This folder is optional.\n services\nThis folder is used to put the services.\n views This folder is used to put all the views. Please remind that for ERP project we will only use two views: list and modify (modify is one view used for create, edit and view).\n [module-name].client.module.js\nThis file is used for register modules with services, routes, and/or external modules.\n  server - Back end related files\n config\nThis folder is used for initializing and declare module dependencies.\n controllers\nThis folder is used for query to database with using mongoosejs.\n models\nThis folder is used for declaring model that will be used in database.\n policies\nThis folder is used for declaring permission for API resources.\n routes\n  This folder is used for declaring route for API.\n Test related files [TO DO - In development]\n  Important Notes Please do remember that core modules will consist of general functions, directives, css, images and constants that often used by other modules. If the functions, directives, css, images and constants only used by one module, do not put in core module put in these modules instead.\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/class-vs-reactcreateclass-vs-stateless/",
	"title": "Class Vs React.createClass Vs Stateless",
	"tags": [],
	"description": "",
	"content": " Class vs React.createClass vs stateless  If you have internal state and/or refs, prefer class extends React.Component over React.createClass. eslint: react/prefer-es6-class react/prefer-stateless-function\n// bad const Listing = React.createClass({ // ... render() { return \u0026lt;div\u0026gt;{this.state.hello}\u0026lt;/div\u0026gt;; } }); // good class Listing extends React.Component { // ... render() { return \u0026lt;div\u0026gt;{this.state.hello}\u0026lt;/div\u0026gt;; } }  And if you don\u0026rsquo;t have state or refs, prefer normal functions (not arrow functions) over classes:\n// bad class Listing extends React.Component { render() { return \u0026lt;div\u0026gt;{this.props.hello}\u0026lt;/div\u0026gt;; } } // bad (relying on function name inference is discouraged) const Listing = ({ hello }) =\u0026gt; ( \u0026lt;div\u0026gt;{hello}\u0026lt;/div\u0026gt; ); // good function Listing({ hello }) { return \u0026lt;div\u0026gt;{hello}\u0026lt;/div\u0026gt;; }   "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/iife/",
	"title": "IIFE",
	"tags": [],
	"description": "",
	"content": " IIFE JavaScript Scopes [Style Y010]  Wrap Angular components in an Immediately Invoked Function Expression (IIFE).  Why?: An IIFE removes variables from the global scope. This helps prevent variables and function declarations from living longer than expected in the global scope, which also helps avoid variable collisions.\nWhy?: When your code is minified and bundled into a single file for deployment to a production server, you could have collisions of variables and many global variables. An IIFE protects you against both of these by providing variable scope for each file.\n/* avoid */ // logger.js angular .module('app') .factory('logger', logger); // logger function is added as a global variable function logger() { } // storage.js angular .module('app') .factory('storage', storage); // storage function is added as a global variable function storage() { }  /** * recommended * * no globals are left behind */ // logger.js (function() { 'use strict'; angular .module('app') .factory('logger', logger); function logger() { } })(); // storage.js (function() { 'use strict'; angular .module('app') .factory('storage', storage); function storage() { } })();  OR…. invocation inside parentheses. This is recomended in MEANJS.\n // logger.js (function() { 'use strict'; angular .module('app') .factory('logger', logger); function logger() { } }()); // storage.js (function() { 'use strict'; angular .module('app') .factory('storage', storage); function storage() { } }());   Note: For brevity only, the rest of the examples in this guide may omit the IIFE syntax.\n Note: IIFE\u0026rsquo;s prevent test code from reaching private members like regular expressions or helper functions which are often good to unit test directly on their own. However you can test these through accessible members or by exposing them through their own component. For example placing helper functions, regular expressions or constants in their own factory or constant.\n  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/meanjs/reference/",
	"title": "Reference",
	"tags": [],
	"description": "",
	"content": " MEAN.JS Documentation Official Documentation\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/mixins/",
	"title": "Mixins",
	"tags": [],
	"description": "",
	"content": " Mixins  Do not use mixins.   Why? Mixins introduce implicit dependencies, cause name clashes, and cause snowballing complexity. Most use cases for mixins can be accomplished in better ways via components, higher-order components, or utility modules.\n "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/modules/",
	"title": "Modules",
	"tags": [],
	"description": "",
	"content": " Modules Avoid Naming Collisions [Style Y020]  Use unique naming conventions with separators for sub-modules.  Why?: Unique names help avoid module name collisions. Separators help define modules and their submodule hierarchy. For example app may be your root module while app.dashboard and app.users may be modules that are used as dependencies of app.\nDefinitions (aka Setters) [Style Y021]  Declare modules without a variable using the setter syntax.  Why?: With 1 component per file, there is rarely a need to introduce a variable for the module.\n/* avoid */ var app = angular.module('app', [ 'ngAnimate', 'ngRoute', 'app.shared', 'app.dashboard' ]);  Instead use the simple setter syntax.\n/* recommended */ angular .module('app', [ 'ngAnimate', 'ngRoute', 'app.shared', 'app.dashboard' ]);  Getters [Style Y022]  When using a module, avoid using a variable and instead use chaining with the getter syntax.  Why?: This produces more readable code and avoids variable collisions or leaks.\n/* avoid */ var app = angular.module('app'); app.controller('SomeController', SomeController); function SomeController() { }  /* recommended */ angular .module('app') .controller('SomeController', SomeController); function SomeController() { }  Setting vs Getting [Style Y023]  Only set once and get for all other instances.  Why?: A module should only be created once, then retrieved from that point and after.\n/* recommended */ // to set a module angular.module('app', []); // to get a module angular.module('app');  Named vs Anonymous Functions [Style Y024]  Use named functions instead of passing an anonymous function in as a callback.  Why?: This produces more readable code, is much easier to debug, and reduces the amount of nested callback code.\n/* avoid */ angular .module('app') .controller('DashboardController', function() { }) .factory('logger', function() { });  /* recommended */ // dashboard.js angular .module('app') .controller('DashboardController', DashboardController); function DashboardController() { }  // logger.js angular .module('app') .factory('logger', logger); function logger() { }  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/meanjs/mean-resources/",
	"title": "MEAN Resources",
	"tags": [],
	"description": "",
	"content": " A Complete Guide to MEAN Stack ❤\nArticles  Full-Stack JavaScript With MEAN And Yeoman Build a real-time polls application with Node.js, Express, AngularJS, and MongoDB AngularJS Tutorial: Learn to Build Modern Web Apps Introduction to the MEAN Stack, Part One: Setting Up Your Tools Introduction to the MEAN Stack, Part Two: Building and Testing a To-do List Price Internationalization with the MEAN Stack The MEAN Stack: MongoDB, ExpressJS, AngularJS, and Node.js Setting Up a MEAN Stack Single Page Application Node and Angular To-Do App Single Page Apps with AngularJS Routing and Templating A Sample App with Node.js, Express and MongoDB – Part 1 A Sample App with Node.js, Express and MongoDB – Part 2 The MEAN Stack: MongoDB, ExpressJS, AngularJS and Node.js - blog MongoDB TDD and BDD With The MEAN Stack: Introduction BDD with MEAN – The Server Part 1 Continuous Integration with the MEAN Stack Intro to the MEAN Stack - Part 1 - The Data REST Service with Web Interface using the MEAN Stack MEAN Stack Resources (MongoDB, ExpressJS, AngularJS \u0026amp; Node.js) Getting Started with Node.js #2: Using OAuth2 in MEAN applications Introduction to the MEAN Stack Creating an RSS Feed Reader With the MEAN Stack Introduction to the MEAN Stack - SitePoint Deploying mean.io to Heroku with ease MEAN Stack – A Quick Start Guide AngularJS Tutorial for Beginners With NodeJS ExpressJS and MongoDB Create a TV Show Tracker using AngularJS, Node.js and MongoDB Deploying a MEAN App to Amazon EC2 Mean Stack Tutorial - for beginners MEAN Stack : Real-time polls application - part 1, part 2  Videos  Getting MEAN Introduction to the MEAN Stack Build a real-time polls application with Node.js, Express, AngularJS, and MongoDB Let\u0026rsquo;s Get CRUDdy: AngularJS and Node.js Ferrari Example M.E.A.N. - a stack do hipsters (pt-br) MEAN stack - episode 1 MEAN Stack RESTful API tutorial  Courses  The complete JavaScript developer: MEAN stack zero-to-hero be MEAN Building AngularJS and Node.js Apps with the MEAN Stack Introdução ao MEAN-Stack MEAN Stack Jump Start by Microsoft Virtual Academy The 30 Day MEAN Stack Honolulu Challenge - Bossable egghead.io - Learn professional JavaScript tools Become a MEAN Stack Developer - Code School Build a course planner for a school with MEAN  Books  MEAN Web Development Getting MEAN with Mongo, Express, Angular, and Node Getting MEAN with Mongo, Express, Angular, and Node, Second Edition Mean: Full stack JavaScript para aplicações web com MongoDB, Express, Angular e Node MEAN Machine - A beginner\u0026rsquo;s practical guide to the JavaScript stack. By Scotch.io MEAN Blueprints Write Modern Web Apps with MEAN Stack by Jeff Dickey Pro MEAN Stack Development  Slides  WELCOME TO THE MEAN STACK: MONGODB, EXPRESS, ANGULARJS, NODE Get MEAN! Node.js and the MEAN stack MEAN Stack  Podcasts  092 JSJ The MEAN Stack with Ward Bell and Valeri Karpov  More Useful Links  THE DEAD-SIMPLE STEP-BY-STEP GUIDE FOR FRONT-END DEVELOPERS TO GETTING UP AND RUNNING WITH NODE.JS, EXPRESS, JADE, AND MONGODB CREATING A SIMPLE RESTFUL WEB APP WITH NODE.JS, EXPRESS, AND MONGODB Heroku - Cloud Application Platform mean.io mean.js NodeJS Learning AngularJS Learning JavaScript Recipes for MEAN stack AngularJS Tutorial: A Comprehensive 10,000 Word Guide  "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/naming/",
	"title": "Naming",
	"tags": [],
	"description": "",
	"content": " Naming  Extensions: Use .jsx extension for React components. Filename: Use PascalCase for filenames. E.g., ReservationCard.jsx. Reference Naming: Use PascalCase for React components and camelCase for their instances. eslint: react/jsx-pascal-case\n// bad import reservationCard from './ReservationCard'; // good import ReservationCard from './ReservationCard'; // bad const ReservationItem = \u0026lt;ReservationCard /\u0026gt;; // good const reservationItem = \u0026lt;ReservationCard /\u0026gt;;  Component Naming: Use the filename as the component name. For example, ReservationCard.jsx should have a reference name of ReservationCard. However, for root components of a directory, use index.jsx as the filename and use the directory name as the component name:\n// bad import Footer from './Footer/Footer'; // bad import Footer from './Footer/index'; // good import Footer from './Footer';  Higher-order Component Naming: Use a composite of the higher-order component\u0026rsquo;s name and the passed-in component\u0026rsquo;s name as the displayName on the generated component. For example, the higher-order component withFoo(), when passed a component Bar should produce a component with a displayName of withFoo(Bar).\n Why? A component\u0026rsquo;s displayName may be used by developer tools or in error messages, and having a value that clearly expresses this relationship helps people understand what is happening.\n // bad export default function withFoo(WrappedComponent) { return function WithFoo(props) { return \u0026lt;WrappedComponent {...props} foo /\u0026gt;; } } // good export default function withFoo(WrappedComponent) { function WithFoo(props) { return \u0026lt;WrappedComponent {...props} foo /\u0026gt;; } const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component'; WithFoo.displayName = `withFoo(${wrappedComponentName})`; return WithFoo; }  Props Naming: Avoid using DOM component prop names for different purposes.\n Why? People expect props like style and className to mean one specific thing. Varying this API for a subset of your app makes the code less readable and less maintainable, and may cause bugs.\n // bad \u0026lt;MyComponent style=\u0026quot;fancy\u0026quot; /\u0026gt; // good \u0026lt;MyComponent variant=\u0026quot;fancy\u0026quot; /\u0026gt;   "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/controllers/",
	"title": "Controllers",
	"tags": [],
	"description": "",
	"content": " Controllers controllerAs View Syntax [Style Y030]  Use the controllerAs syntax over the classic controller with $scope syntax.  Why?: Controllers are constructed, \u0026ldquo;newed\u0026rdquo; up, and provide a single new instance, and the controllerAs syntax is closer to that of a JavaScript constructor than the classic $scope syntax.\nWhy?: It promotes the use of binding to a \u0026ldquo;dotted\u0026rdquo; object in the View (e.g. customer.name instead of name), which is more contextual, easier to read, and avoids any reference issues that may occur without \u0026ldquo;dotting\u0026rdquo;.\nWhy?: Helps avoid using $parent calls in Views with nested controllers.\n\u0026lt;!-- avoid --\u0026gt; \u0026lt;div ng-controller=\u0026quot;CustomerController\u0026quot;\u0026gt; {{ name }} \u0026lt;/div\u0026gt;  \u0026lt;!-- recommended --\u0026gt; \u0026lt;div ng-controller=\u0026quot;CustomerController as customer\u0026quot;\u0026gt; {{ customer.name }} \u0026lt;/div\u0026gt;  controllerAs Controller Syntax [Style Y031]  Use the controllerAs syntax over the classic controller with $scope syntax.\n The controllerAs syntax uses this inside controllers which gets bound to $scope\n  Why?: controllerAs is syntactic sugar over $scope. You can still bind to the View and still access $scope methods.\nWhy?: Helps avoid the temptation of using $scope methods inside a controller when it may otherwise be better to avoid them or move the method to a factory, and reference them from the controller. Consider using $scope in a controller only when needed. For example when publishing and subscribing events using $emit, $broadcast, or $on.\n/* avoid */ function CustomerController($scope) { $scope.name = {}; $scope.sendMessage = function() { }; }  /* recommended - but see next section */ function CustomerController() { this.name = {}; this.sendMessage = function() { }; }  controllerAs with vm [Style Y032]  Use a capture variable for this when using the controllerAs syntax. Choose a consistent variable name such as vm, which stands for ViewModel.  Why?: The this keyword is contextual and when used within a function inside a controller may change its context. Capturing the context of this avoids encountering this problem.\n/* avoid */ function CustomerController() { this.name = {}; this.sendMessage = function() { }; }  /* recommended */ function CustomerController() { var vm = this; vm.name = {}; vm.sendMessage = function() { }; }  Note: You can avoid any jshint warnings by placing the comment above the line of code. However it is not needed when the function is named using UpperCasing, as this convention means it is a constructor function, which is what a controller is in Angular.\n/* jshint validthis: true */ var vm = this;  Note: When creating watches in a controller using controller as, you can watch the vm.* member using the following syntax. (Create watches with caution as they add more load to the digest cycle.)\n\u0026lt;input ng-model=\u0026quot;vm.title\u0026quot;/\u0026gt;  function SomeController($scope, $log) { var vm = this; vm.title = 'Some Title'; $scope.$watch('vm.title', function(current, original) { $log.info('vm.title was %s', original); $log.info('vm.title is now %s', current); }); }  Note: When working with larger codebases, using a more descriptive name can help ease cognitive overhead \u0026amp; searchability. Avoid overly verbose names that are cumbersome to type.\n\u0026lt;!-- avoid --\u0026gt; \u0026lt;input ng-model=\u0026quot;customerProductItemVm.title\u0026quot;\u0026gt;  \u0026lt;!-- recommended --\u0026gt; \u0026lt;input ng-model=\u0026quot;productVm.title\u0026quot;\u0026gt;  Bindable Members Up Top [Style Y033]  Place bindable members at the top of the controller, alphabetized, and not spread through the controller code.\nWhy?: Placing bindable members at the top makes it easy to read and helps you instantly identify which members of the controller can be bound and used in the View.\nWhy?: Setting anonymous functions in-line can be easy, but when those functions are more than 1 line of code they can reduce the readability. Defining the functions below the bindable members (the functions will be hoisted) moves the implementation details down, keeps the bindable members up top, and makes it easier to read.\n  /* avoid */ function SessionsController() { var vm = this; vm.gotoSession = function() { /* ... */ }; vm.refresh = function() { /* ... */ }; vm.search = function() { /* ... */ }; vm.sessions = []; vm.title = 'Sessions'; }  /* recommended */ function SessionsController() { var vm = this; vm.gotoSession = gotoSession; vm.refresh = refresh; vm.search = search; vm.sessions = []; vm.title = 'Sessions'; //////////// function gotoSession() { /* */ } function refresh() { /* */ } function search() { /* */ } }  ![Controller Using \u0026quot;Above the Fold\u0026quot;](https://raw.githubusercontent.com/johnpapa/angular-styleguide/master/a1/assets/above-the-fold-1.png)  Note: If the function is a 1 liner consider keeping it right up top, as long as readability is not affected.\n/* avoid */ function SessionsController(data) { var vm = this; vm.gotoSession = gotoSession; vm.refresh = function() { /** * lines * of * code * affects * readability */ }; vm.search = search; vm.sessions = []; vm.title = 'Sessions'; }  /* recommended */ function SessionsController(sessionDataService) { var vm = this; vm.gotoSession = gotoSession; vm.refresh = sessionDataService.refresh; // 1 liner is OK vm.search = search; vm.sessions = []; vm.title = 'Sessions'; }  Function Declarations to Hide Implementation Details [Style Y034]  Use function declarations to hide implementation details. Keep your bindable members up top. When you need to bind a function in a controller, point it to a function declaration that appears later in the file. This is tied directly to the section Bindable Members Up Top. For more details see this post.\nWhy?: Placing bindable members at the top makes it easy to read and helps you instantly identify which members of the controller can be bound and used in the View. (Same as above.)\nWhy?: Placing the implementation details of a function later in the file moves that complexity out of view so you can see the important stuff up top.\nWhy?: Function declarations are hoisted so there are no concerns over using a function before it is defined (as there would be with function expressions).\nWhy?: You never have to worry with function declarations that moving var a before var b will break your code because a depends on b.\nWhy?: Order is critical with function expressions\n  /** * avoid * Using function expressions. */ function AvengersController(avengersService, logger) { var vm = this; vm.avengers = []; vm.title = 'Avengers'; var activate = function() { return getAvengers().then(function() { logger.info('Activated Avengers View'); }); } var getAvengers = function() { return avengersService.getAvengers().then(function(data) { vm.avengers = data; return vm.avengers; }); } vm.getAvengers = getAvengers; activate(); }  Notice that the important stuff is scattered in the preceding example. In the example below, notice that the important stuff is up top. For example, the members bound to the controller such as vm.avengers and vm.title. The implementation details are down below. This is just easier to read.\n/* * recommend * Using function declarations * and bindable members up top. */ function AvengersController(avengersService, logger) { var vm = this; vm.avengers = []; vm.getAvengers = getAvengers; vm.title = 'Avengers'; activate(); function activate() { return getAvengers().then(function() { logger.info('Activated Avengers View'); }); } function getAvengers() { return avengersService.getAvengers().then(function(data) { vm.avengers = data; return vm.avengers; }); } }  Defer Controller Logic to Services [Style Y035]  Defer logic in a controller by delegating to services and factories.\nWhy?: Logic may be reused by multiple controllers when placed within a service and exposed via a function.\nWhy?: Logic in a service can more easily be isolated in a unit test, while the calling logic in the controller can be easily mocked.\nWhy?: Removes dependencies and hides implementation details from the controller.\nWhy?: Keeps the controller slim, trim, and focused.\n  /* avoid */ function OrderController($http, $q, config, userInfo) { var vm = this; vm.checkCredit = checkCredit; vm.isCreditOk; vm.total = 0; function checkCredit() { var settings = {}; // Get the credit service base URL from config // Set credit service required headers // Prepare URL query string or data object with request data // Add user-identifying info so service gets the right credit limit for this user. // Use JSONP for this browser if it doesn't support CORS return $http.get(settings) .then(function(data) { // Unpack JSON data in the response object // to find maxRemainingAmount vm.isCreditOk = vm.total \u0026lt;= maxRemainingAmount }) .catch(function(error) { // Interpret error // Cope w/ timeout? retry? try alternate service? // Re-reject with appropriate error for a user to see }); }; }  /* recommended */ function OrderController(creditService) { var vm = this; vm.checkCredit = checkCredit; vm.isCreditOk; vm.total = 0; function checkCredit() { return creditService.isOrderTotalOk(vm.total) .then(function(isOk) { vm.isCreditOk = isOk; }) .catch(showError); }; }  Keep Controllers Focused [Style Y037]  Define a controller for a view, and try not to reuse the controller for other views. Instead, move reusable logic to factories and keep the controller simple and focused on its view.\nWhy?: Reusing controllers with several views is brittle and good end-to-end (e2e) test coverage is required to ensure stability across large applications.\n  Assigning Controllers [Style Y038]  When a controller must be paired with a view and either component may be re-used by other controllers or views, define controllers along with their routes.\nNote: If a View is loaded via another means besides a route, then use the ng-controller=\u0026quot;Avengers as vm\u0026quot; syntax.\nWhy?: Pairing the controller in the route allows different routes to invoke different pairs of controllers and views. When controllers are assigned in the view using ng-controller, that view is always associated with the same controller.\n  /* avoid - when using with a route and dynamic pairing is desired */ // route-config.js angular .module('app') .config(config); function config($routeProvider) { $routeProvider .when('/avengers', { templateUrl: 'avengers.html' }); }  \u0026lt;!-- avengers.html --\u0026gt; \u0026lt;div ng-controller=\u0026quot;AvengersController as vm\u0026quot;\u0026gt; \u0026lt;/div\u0026gt;  /* recommended */ // route-config.js angular .module('app') .config(config); function config($routeProvider) { $routeProvider .when('/avengers', { templateUrl: 'avengers.html', controller: 'Avengers', controllerAs: 'vm' }); }  \u0026lt;!-- avengers.html --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt;  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/declaration/",
	"title": "Declaration",
	"tags": [],
	"description": "",
	"content": " Declaration  Do not use displayName for naming components. Instead, name the component by reference.\n// bad export default React.createClass({ displayName: 'ReservationCard', // stuff goes here }); // good export default class ReservationCard extends React.Component { }   "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/services/",
	"title": "Services",
	"tags": [],
	"description": "",
	"content": " Services Singletons [Style Y040]  Services are instantiated with the new keyword, use this for public methods and variables. Since these are so similar to factories, use a factory instead for consistency.\nNote: All Angular services are singletons. This means that there is only one instance of a given service per injector.\n  // service angular .module('app') .service('logger', logger); function logger() { this.logError = function(msg) { /* */ }; }  // factory angular .module('app') .factory('logger', logger); function logger() { return { logError: function(msg) { /* */ } }; }  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/alignment/",
	"title": "Alignment",
	"tags": [],
	"description": "",
	"content": " Alignment  Follow these alignment styles for JSX syntax. eslint: react/jsx-closing-bracket-location\n// bad \u0026lt;Foo superLongParam=\u0026quot;bar\u0026quot; anotherSuperLongParam=\u0026quot;baz\u0026quot; /\u0026gt; // good \u0026lt;Foo superLongParam=\u0026quot;bar\u0026quot; anotherSuperLongParam=\u0026quot;baz\u0026quot; /\u0026gt; // if props fit in one line then keep it on the same line \u0026lt;Foo bar=\u0026quot;bar\u0026quot; /\u0026gt; // children get indented normally \u0026lt;Foo superLongParam=\u0026quot;bar\u0026quot; anotherSuperLongParam=\u0026quot;baz\u0026quot; \u0026gt; \u0026lt;Quux /\u0026gt; \u0026lt;/Foo\u0026gt;   "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/factories/",
	"title": "Factories",
	"tags": [],
	"description": "",
	"content": " Factories Single Responsibility [Style Y050]  Factories should have a single responsibility, that is encapsulated by its context. Once a factory begins to exceed that singular purpose, a new factory should be created.  Singletons [Style Y051]  Factories are singletons and return an object that contains the members of the service.\nNote: All Angular services are singletons.\n  Accessible Members Up Top [Style Y052]  Expose the callable members of the service (its interface) at the top, using a technique derived from the Revealing Module Pattern.\nWhy?: Placing the callable members at the top makes it easy to read and helps you instantly identify which members of the service can be called and must be unit tested (and/or mocked).\nWhy?: This is especially helpful when the file gets longer as it helps avoid the need to scroll to see what is exposed.\nWhy?: Setting functions as you go can be easy, but when those functions are more than 1 line of code they can reduce the readability and cause more scrolling. Defining the callable interface via the returned service moves the implementation details down, keeps the callable interface up top, and makes it easier to read.\n  /* avoid */ function dataService() { var someValue = ''; function save() { /* */ }; function validate() { /* */ }; return { save: save, someValue: someValue, validate: validate }; }  /* recommended */ function dataService() { var someValue = ''; var service = { save: save, someValue: someValue, validate: validate }; return service; //////////// function save() { /* */ }; function validate() { /* */ }; }  This way bindings are mirrored across the host object, primitive values cannot update alone using the revealing module pattern.\n![Factories Using \u0026quot;Above the Fold\u0026quot;](https://raw.githubusercontent.com/johnpapa/angular-styleguide/master/a1/assets/above-the-fold-2.png)  Function Declarations to Hide Implementation Details [Style Y053]  Use function declarations to hide implementation details. Keep your accessible members of the factory up top. Point those to function declarations that appears later in the file. For more details see this post.\nWhy?: Placing accessible members at the top makes it easy to read and helps you instantly identify which functions of the factory you can access externally.\nWhy?: Placing the implementation details of a function later in the file moves that complexity out of view so you can see the important stuff up top.\nWhy?: Function declarations are hoisted so there are no concerns over using a function before it is defined (as there would be with function expressions).\nWhy?: You never have to worry with function declarations that moving var a before var b will break your code because a depends on b.\nWhy?: Order is critical with function expressions\n  /** * avoid * Using function expressions */ function dataservice($http, $location, $q, exception, logger) { var isPrimed = false; var primePromise; var getAvengers = function() { // implementation details go here }; var getAvengerCount = function() { // implementation details go here }; var getAvengersCast = function() { // implementation details go here }; var prime = function() { // implementation details go here }; var ready = function(nextPromises) { // implementation details go here }; var service = { getAvengersCast: getAvengersCast, getAvengerCount: getAvengerCount, getAvengers: getAvengers, ready: ready }; return service; }  /** * recommended * Using function declarations * and accessible members up top. */ function dataservice($http, $location, $q, exception, logger) { var isPrimed = false; var primePromise; var service = { getAvengersCast: getAvengersCast, getAvengerCount: getAvengerCount, getAvengers: getAvengers, ready: ready }; return service; //////////// function getAvengers() { // implementation details go here } function getAvengerCount() { // implementation details go here } function getAvengersCast() { // implementation details go here } function prime() { // implementation details go here } function ready(nextPromises) { // implementation details go here } }  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/quotes/",
	"title": "Quotes",
	"tags": [],
	"description": "",
	"content": " Quotes  Always use double quotes (\u0026quot;) for JSX attributes, but single quotes (') for all other JS. eslint: jsx-quotes\n Why? Regular HTML attributes also typically use double quotes instead of single, so JSX attributes mirror this convention.\n // bad \u0026lt;Foo bar='bar' /\u0026gt; // good \u0026lt;Foo bar=\u0026quot;bar\u0026quot; /\u0026gt; // bad \u0026lt;Foo style={{ left: \u0026quot;20px\u0026quot; }} /\u0026gt; // good \u0026lt;Foo style={{ left: '20px' }} /\u0026gt;   "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/data-services/",
	"title": "Data Services",
	"tags": [],
	"description": "",
	"content": " Data Services Separate Data Calls [Style Y060]  Refactor logic for making data operations and interacting with data to a factory. Make data services responsible for XHR calls, local storage, stashing in memory, or any other data operations.\nWhy?: The controller\u0026rsquo;s responsibility is for the presentation and gathering of information for the view. It should not care how it gets the data, just that it knows who to ask for it. Separating the data services moves the logic on how to get it to the data service, and lets the controller be simpler and more focused on the view.\nWhy?: This makes it easier to test (mock or real) the data calls when testing a controller that uses a data service.\nWhy?: Data service implementation may have very specific code to handle the data repository. This may include headers, how to talk to the data, or other services such as $http. Separating the logic into a data service encapsulates this logic in a single place hiding the implementation from the outside consumers (perhaps a controller), also making it easier to change the implementation.\n  /* recommended */ // dataservice factory angular .module('app.core') .factory('dataservice', dataservice); dataservice.$inject = ['$http', 'logger']; function dataservice($http, logger) { return { getAvengers: getAvengers }; function getAvengers() { return $http.get('/api/maa') .then(getAvengersComplete) .catch(getAvengersFailed); function getAvengersComplete(response) { return response.data.results; } function getAvengersFailed(error) { logger.error('XHR Failed for getAvengers.' + error.data); } } }  Note: The data service is called from consumers, such as a controller, hiding the implementation from the consumers, as shown below.  /* recommended */ // controller calling the dataservice factory angular .module('app.avengers') .controller('AvengersController', AvengersController); AvengersController.$inject = ['dataservice', 'logger']; function AvengersController(dataservice, logger) { var vm = this; vm.avengers = []; activate(); function activate() { return getAvengers().then(function() { logger.info('Activated Avengers View'); }); } function getAvengers() { return dataservice.getAvengers() .then(function(data) { vm.avengers = data; return vm.avengers; }); } }  Return a Promise from Data Calls [Style Y061]  When calling a data service that returns a promise such as $http, return a promise in your calling function too.\nWhy?: You can chain the promises together and take further action after the data call completes and resolves or rejects the promise.\n  /* recommended */ activate(); function activate() { /** * Step 1 * Ask the getAvengers function for the * avenger data and wait for the promise */ return getAvengers().then(function() { /** * Step 4 * Perform an action on resolve of final promise */ logger.info('Activated Avengers View'); }); } function getAvengers() { /** * Step 2 * Ask the data service for the data and wait * for the promise */ return dataservice.getAvengers() .then(function(data) { /** * Step 3 * set the data and resolve the promise */ vm.avengers = data; return vm.avengers; }); }  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/spacing/",
	"title": "Spacing",
	"tags": [],
	"description": "",
	"content": " Spacing  Always include a single space in your self-closing tag. eslint: no-multi-spaces, react/jsx-tag-spacing\n// bad \u0026lt;Foo/\u0026gt; // very bad \u0026lt;Foo /\u0026gt; // bad \u0026lt;Foo /\u0026gt; // good \u0026lt;Foo /\u0026gt;  Do not pad JSX curly braces with spaces. eslint: react/jsx-curly-spacing\n// bad \u0026lt;Foo bar={ baz } /\u0026gt; // good \u0026lt;Foo bar={baz} /\u0026gt;   "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/directives/",
	"title": "Directives",
	"tags": [],
	"description": "",
	"content": " Directives Limit 1 Per File [Style Y070]  Create one directive per file. Name the file for the directive.\nWhy?: It is easy to mash all the directives in one file, but difficult to then break those out so some are shared across apps, some across modules, some just for one module.\nWhy?: One directive per file is easy to maintain.\n Note: \u0026ldquo;Best Practice: Directives should clean up after themselves. You can use element.on('$destroy', ...) or scope.$on('$destroy', ...) to run a clean-up function when the directive is removed\u0026rdquo; \u0026hellip; from the Angular documentation.\n  /* avoid */ /* directives.js */ angular .module('app.widgets') /* order directive that is specific to the order module */ .directive('orderCalendarRange', orderCalendarRange) /* sales directive that can be used anywhere across the sales app */ .directive('salesCustomerInfo', salesCustomerInfo) /* spinner directive that can be used anywhere across apps */ .directive('sharedSpinner', sharedSpinner); function orderCalendarRange() { /* implementation details */ } function salesCustomerInfo() { /* implementation details */ } function sharedSpinner() { /* implementation details */ }  /* recommended */ /* calendar-range.directive.js */ /** * @desc order directive that is specific to the order module at a company named Acme * @example \u0026lt;div acme-order-calendar-range\u0026gt;\u0026lt;/div\u0026gt; */ angular .module('sales.order') .directive('acmeOrderCalendarRange', orderCalendarRange); function orderCalendarRange() { /* implementation details */ }  /* recommended */ /* customer-info.directive.js */ /** * @desc sales directive that can be used anywhere across the sales app at a company named Acme * @example \u0026lt;div acme-sales-customer-info\u0026gt;\u0026lt;/div\u0026gt; */ angular .module('sales.widgets') .directive('acmeSalesCustomerInfo', salesCustomerInfo); function salesCustomerInfo() { /* implementation details */ }  /* recommended */ /* spinner.directive.js */ /** * @desc spinner directive that can be used anywhere across apps at a company named Acme * @example \u0026lt;div acme-shared-spinner\u0026gt;\u0026lt;/div\u0026gt; */ angular .module('shared.widgets') .directive('acmeSharedSpinner', sharedSpinner); function sharedSpinner() { /* implementation details */ }  Note: There are many naming options for directives, especially since they can be used in narrow or wide scopes. Choose one that makes the directive and its file name distinct and clear. Some examples are below, but see the [Naming](#naming) section for more recommendations.  Manipulate DOM in a Directive [Style Y072]  When manipulating the DOM directly, use a directive. If alternative ways can be used such as using CSS to set styles or the animation services, Angular templating, ngShow or ngHide, then use those instead. For example, if the directive simply hides and shows, use ngHide/ngShow.\nWhy?: DOM manipulation can be difficult to test, debug, and there are often better ways (e.g. CSS, animations, templates)\n  Provide a Unique Directive Prefix [Style Y073]  Provide a short, unique and descriptive directive prefix such as acmeSalesCustomerInfo which would be declared in HTML as acme-sales-customer-info.\nWhy?: The unique short prefix identifies the directive\u0026rsquo;s context and origin. For example a prefix of cc- may indicate that the directive is part of a CodeCamper app while acme- may indicate a directive for the Acme company.\nNote: Avoid ng- as these are reserved for Angular directives. Research widely used directives to avoid naming conflicts, such as ion- for the Ionic Framework.\n  Restrict to Elements and Attributes [Style Y074]  When creating a directive that makes sense as a stand-alone element, allow restrict E (custom element) and optionally restrict A (custom attribute). Generally, if it could be its own control, E is appropriate. General guideline is allow EA but lean towards implementing as an element when it\u0026rsquo;s stand-alone and as an attribute when it enhances its existing DOM element.\nWhy?: It makes sense.\nWhy?: While we can allow the directive to be used as a class, if the directive is truly acting as an element it makes more sense as an element or at least as an attribute.\nNote: EA is the default for Angular 1.3 +\n  \u0026lt;!-- avoid --\u0026gt; \u0026lt;div class=\u0026quot;my-calendar-range\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;  /* avoid */ angular .module('app.widgets') .directive('myCalendarRange', myCalendarRange); function myCalendarRange() { var directive = { link: link, templateUrl: '/template/is/located/here.html', restrict: 'C' }; return directive; function link(scope, element, attrs) { /* */ } }  \u0026lt;!-- recommended --\u0026gt; \u0026lt;my-calendar-range\u0026gt;\u0026lt;/my-calendar-range\u0026gt; \u0026lt;div my-calendar-range\u0026gt;\u0026lt;/div\u0026gt;  /* recommended */ angular .module('app.widgets') .directive('myCalendarRange', myCalendarRange); function myCalendarRange() { var directive = { link: link, templateUrl: '/template/is/located/here.html', restrict: 'EA' }; return directive; function link(scope, element, attrs) { /* */ } }  Directives and ControllerAs [Style Y075]  Use controllerAs syntax with a directive to be consistent with using controller as with view and controller pairings.\nWhy?: It makes sense and it\u0026rsquo;s not difficult.\nNote: The directive below demonstrates some of the ways you can use scope inside of link and directive controllers, using controllerAs. I in-lined the template just to keep it all in one place.\nNote: Regarding dependency injection, see Manually Identify Dependencies.\nNote: Note that the directive\u0026rsquo;s controller is outside the directive\u0026rsquo;s closure. This style eliminates issues where the injection gets created as unreachable code after a return.\nNote: Life-style hooks were introduced in Angular 1.5. Initialization logic that relies on bindings being present should be put in the controller\u0026rsquo;s $onInit() method, which is guarranteed to always be called after the bindings have been assigned.\n  \u0026lt;div my-example max=\u0026quot;77\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;  angular .module('app') .directive('myExample', myExample); function myExample() { var directive = { restrict: 'EA', templateUrl: 'app/feature/example.directive.html', scope: { max: '=' }, link: linkFunc, controller: ExampleController, // note: This would be 'ExampleController' (the exported controller name, as string) // if referring to a defined controller in its separate file. controllerAs: 'vm', bindToController: true // because the scope is isolated }; return directive; function linkFunc(scope, el, attr, ctrl) { console.log('LINK: scope.min = %s *** should be undefined', scope.min); console.log('LINK: scope.max = %s *** should be undefined', scope.max); console.log('LINK: scope.vm.min = %s', scope.vm.min); console.log('LINK: scope.vm.max = %s', scope.vm.max); } } ExampleController.$inject = ['$scope']; function ExampleController($scope) { // Injecting $scope just for comparison var vm = this; vm.min = 3; vm.$onInit = onInit; ////////// console.log('CTRL: $scope.vm.min = %s', $scope.vm.min); console.log('CTRL: $scope.vm.max = %s', $scope.vm.max); // undefined in Angular 1.5+ console.log('CTRL: vm.min = %s', vm.min); console.log('CTRL: vm.max = %s', vm.max); // undefined in Angular 1.5+ // Angular 1.5+ does not bind attributes until calling $onInit(); function onInit() { console.log('CTRL-onInit: $scope.vm.min = %s', $scope.vm.min); console.log('CTRL-onInit: $scope.vm.max = %s', $scope.vm.max); console.log('CTRL-onInit: vm.min = %s', vm.min); console.log('CTRL-onInit: vm.max = %s', vm.max); } }  \u0026lt;!-- example.directive.html --\u0026gt; \u0026lt;div\u0026gt;hello world\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;max={{vm.max}}\u0026lt;input ng-model=\u0026quot;vm.max\u0026quot;/\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;min={{vm.min}}\u0026lt;input ng-model=\u0026quot;vm.min\u0026quot;/\u0026gt;\u0026lt;/div\u0026gt;  Note: You can also name the controller when you inject it into the link function and access directive attributes as properties of the controller.  // Alternative to above example function linkFunc(scope, el, attr, vm) { console.log('LINK: scope.min = %s *** should be undefined', scope.min); console.log('LINK: scope.max = %s *** should be undefined', scope.max); console.log('LINK: vm.min = %s', vm.min); console.log('LINK: vm.max = %s', vm.max); }  [Style Y076]  Use bindToController = true when using controller as syntax with a directive when you want to bind the outer scope to the directive\u0026rsquo;s controller\u0026rsquo;s scope.\nWhy?: It makes it easy to bind outer scope to the directive\u0026rsquo;s controller scope.\nNote: bindToController was introduced in Angular 1.3.0.\n  \u0026lt;div my-example max=\u0026quot;77\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;  angular .module('app') .directive('myExample', myExample); function myExample() { var directive = { restrict: 'EA', templateUrl: 'app/feature/example.directive.html', scope: { max: '=' }, controller: ExampleController, controllerAs: 'vm', bindToController: true }; return directive; } function ExampleController() { var vm = this; vm.min = 3; vm.$onInit = onInit; function onInit() = { console.log('CTRL: vm.min = %s', vm.min); console.log('CTRL: vm.max = %s', vm.max); } }  \u0026lt;!-- example.directive.html --\u0026gt; \u0026lt;div\u0026gt;hello world\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;max={{vm.max}}\u0026lt;input ng-model=\u0026quot;vm.max\u0026quot;/\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;min={{vm.min}}\u0026lt;input ng-model=\u0026quot;vm.min\u0026quot;/\u0026gt;\u0026lt;/div\u0026gt;  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/props/",
	"title": "Props",
	"tags": [],
	"description": "",
	"content": " Props  Always use camelCase for prop names.\n// bad \u0026lt;Foo UserName=\u0026quot;hello\u0026quot; phone_number={12345678} /\u0026gt; // good \u0026lt;Foo userName=\u0026quot;hello\u0026quot; phoneNumber={12345678} /\u0026gt;  Omit the value of the prop when it is explicitly true. eslint: react/jsx-boolean-value\n// bad \u0026lt;Foo hidden={true} /\u0026gt; // good \u0026lt;Foo hidden /\u0026gt;  Always include an alt prop on \u0026lt;img\u0026gt; tags. If the image is presentational, alt can be an empty string or the \u0026lt;img\u0026gt; must have role=\u0026quot;presentation\u0026quot;. eslint: jsx-a11y/alt-text\n// bad \u0026lt;img src=\u0026quot;hello.jpg\u0026quot; /\u0026gt; // good \u0026lt;img src=\u0026quot;hello.jpg\u0026quot; alt=\u0026quot;Me waving hello\u0026quot; /\u0026gt; // good \u0026lt;img src=\u0026quot;hello.jpg\u0026quot; alt=\u0026quot;\u0026quot; /\u0026gt; // good \u0026lt;img src=\u0026quot;hello.jpg\u0026quot; role=\u0026quot;presentation\u0026quot; /\u0026gt;  Do not use words like \u0026ldquo;image\u0026rdquo;, \u0026ldquo;photo\u0026rdquo;, or \u0026ldquo;picture\u0026rdquo; in \u0026lt;img\u0026gt; alt props. eslint: jsx-a11y/img-redundant-alt\n Why? Screenreaders already announce img elements as images, so there is no need to include this information in the alt text.\n // bad \u0026lt;img src=\u0026quot;hello.jpg\u0026quot; alt=\u0026quot;Picture of me waving hello\u0026quot; /\u0026gt; // good \u0026lt;img src=\u0026quot;hello.jpg\u0026quot; alt=\u0026quot;Me waving hello\u0026quot; /\u0026gt;  Use only valid, non-abstract ARIA roles. eslint: jsx-a11y/aria-role\n// bad - not an ARIA role \u0026lt;div role=\u0026quot;datepicker\u0026quot; /\u0026gt; // bad - abstract ARIA role \u0026lt;div role=\u0026quot;range\u0026quot; /\u0026gt; // good \u0026lt;div role=\u0026quot;button\u0026quot; /\u0026gt;  Do not use accessKey on elements. eslint: jsx-a11y/no-access-key\n   Why? Inconsistencies between keyboard shortcuts and keyboard commands used by people using screenreaders and keyboards complicate accessibility.\n // bad \u0026lt;div accessKey=\u0026quot;h\u0026quot; /\u0026gt; // good \u0026lt;div /\u0026gt;   Avoid using an array index as key prop, prefer a unique ID. (why?)  // bad {todos.map((todo, index) =\u0026gt; \u0026lt;Todo {...todo} key={index} /\u0026gt; )} // good {todos.map(todo =\u0026gt; ( \u0026lt;Todo {...todo} key={todo.id} /\u0026gt; ))}   Always define explicit defaultProps for all non-required props.   Why? propTypes are a form of documentation, and providing defaultProps means the reader of your code doesn’t have to assume as much. In addition, it can mean that your code can omit certain type checks.\n // bad function SFC({ foo, bar, children }) { return \u0026lt;div\u0026gt;{foo}{bar}{children}\u0026lt;/div\u0026gt;; } SFC.propTypes = { foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node, }; // good function SFC({ foo, bar, children }) { return \u0026lt;div\u0026gt;{foo}{bar}{children}\u0026lt;/div\u0026gt;; } SFC.propTypes = { foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node, }; SFC.defaultProps = { bar: '', children: null, };  "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/resolving-promises/",
	"title": "Resolving Promises",
	"tags": [],
	"description": "",
	"content": " Resolving Promises Controller Activation Promises [Style Y080]  Resolve start-up logic for a controller in an activate function.\nWhy?: Placing start-up logic in a consistent place in the controller makes it easier to locate, more consistent to test, and helps avoid spreading out the activation logic across the controller.\nWhy?: The controller activate makes it convenient to re-use the logic for a refresh for the controller/View, keeps the logic together, gets the user to the View faster, makes animations easy on the ng-view or ui-view, and feels snappier to the user.\nNote: If you need to conditionally cancel the route before you start using the controller, use a route resolve instead.\n  /* avoid */ function AvengersController(dataservice) { var vm = this; vm.avengers = []; vm.title = 'Avengers'; dataservice.getAvengers().then(function(data) { vm.avengers = data; return vm.avengers; }); }  /* recommended */ function AvengersController(dataservice) { var vm = this; vm.avengers = []; vm.title = 'Avengers'; activate(); //////////// function activate() { return dataservice.getAvengers().then(function(data) { vm.avengers = data; return vm.avengers; }); } }  Route Resolve Promises [Style Y081]  When a controller depends on a promise to be resolved before the controller is activated, resolve those dependencies in the $routeProvider before the controller logic is executed. If you need to conditionally cancel a route before the controller is activated, use a route resolver.\n Use a route resolve when you want to decide to cancel the route before ever transitioning to the View.\nWhy?: A controller may require data before it loads. That data may come from a promise via a custom factory or $http. Using a route resolve allows the promise to resolve before the controller logic executes, so it might take action based on that data from the promise.\nWhy?: The code executes after the route and in the controller’s activate function. The View starts to load right away. Data binding kicks in when the activate promise resolves. A “busy” animation can be shown during the view transition (via ng-view or ui-view)\nNote: The code executes before the route via a promise. Rejecting the promise cancels the route. Resolve makes the new view wait for the route to resolve. A “busy” animation can be shown before the resolve and through the view transition. If you want to get to the View faster and do not require a checkpoint to decide if you can get to the View, consider the controller activate technique instead.\n  /* avoid */ angular .module('app') .controller('AvengersController', AvengersController); function AvengersController(movieService) { var vm = this; // unresolved vm.movies; // resolved asynchronously movieService.getMovies().then(function(response) { vm.movies = response.movies; }); }  /* better */ // route-config.js angular .module('app') .config(config); function config($routeProvider) { $routeProvider .when('/avengers', { templateUrl: 'avengers.html', controller: 'AvengersController', controllerAs: 'vm', resolve: { moviesPrepService: function(movieService) { return movieService.getMovies(); } } }); } // avengers.js angular .module('app') .controller('AvengersController', AvengersController); AvengersController.$inject = ['moviesPrepService']; function AvengersController(moviesPrepService) { var vm = this; vm.movies = moviesPrepService.movies; }  Note: The example below shows the route resolve points to a named function, which is easier to debug and easier to handle dependency injection.  /* even better */ // route-config.js angular .module('app') .config(config); function config($routeProvider) { $routeProvider .when('/avengers', { templateUrl: 'avengers.html', controller: 'AvengersController', controllerAs: 'vm', resolve: { moviesPrepService: moviesPrepService } }); } function moviesPrepService(movieService) { return movieService.getMovies(); } // avengers.js angular .module('app') .controller('AvengersController', AvengersController); AvengersController.$inject = ['moviesPrepService']; function AvengersController(moviesPrepService) { var vm = this; vm.movies = moviesPrepService.movies; }  Note: The code example's dependency on `movieService` is not minification safe on its own. For details on how to make this code minification safe, see the sections on [dependency injection](#manual-annotating-for-dependency-injection) and on [minification and annotation](#minification-and-annotation).  Back to top\nHandling Exceptions with Promises [Style Y082]  The catch block of a promise must return a rejected promise to maintain the exception in the promise chain.\n Always handle exceptions in services/factories.\nWhy?: If the catch block does not return a rejected promise, the caller of the promise will not know an exception occurred. The caller\u0026rsquo;s then will execute. Thus, the user may never know what happened.\nWhy?: To avoid swallowing errors and misinforming the user.\nNote: Consider putting any exception handling in a function in a shared module and service.\n  /* avoid */ function getCustomer(id) { return $http.get('/api/customer/' + id) .then(getCustomerComplete) .catch(getCustomerFailed); function getCustomerComplete(data, status, headers, config) { return data.data; } function getCustomerFailed(e) { var newMessage = 'XHR Failed for getCustomer' if (e.data \u0026amp;\u0026amp; e.data.description) { newMessage = newMessage + '\\n' + e.data.description; } e.data.description = newMessage; logger.error(newMessage); // *** // Notice there is no return of the rejected promise // *** } }  /* recommended */ function getCustomer(id) { return $http.get('/api/customer/' + id) .then(getCustomerComplete) .catch(getCustomerFailed); function getCustomerComplete(data, status, headers, config) { return data.data; } function getCustomerFailed(e) { var newMessage = 'XHR Failed for getCustomer' if (e.data \u0026amp;\u0026amp; e.data.description) { newMessage = newMessage + '\\n' + e.data.description; } e.data.description = newMessage; logger.error(newMessage); return $q.reject(e); } }  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/refs/",
	"title": "Refs",
	"tags": [],
	"description": "",
	"content": " Refs  Always use ref callbacks. eslint: react/no-string-refs\n// bad \u0026lt;Foo ref=\u0026quot;myRef\u0026quot; /\u0026gt; // good \u0026lt;Foo ref={(ref) =\u0026gt; { this.myRef = ref; }} /\u0026gt;   "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/manual-annotating-for-dependency-injection/",
	"title": "Manual Annotating for Dependencies Injection",
	"tags": [],
	"description": "",
	"content": " Manual Annotating for Dependency Injection UnSafe from Minification [Style Y090]  Avoid using the shortcut syntax of declaring dependencies without using a minification-safe approach.\nWhy?: The parameters to the component (e.g. controller, factory, etc) will be converted to mangled variables. For example, common and dataservice may become a or b and not be found by Angular.\n/* avoid - not minification-safe*/ angular .module('app') .controller('DashboardController', DashboardController); function DashboardController(common, dataservice) { }  This code may produce mangled variables when minified and thus cause runtime errors.\n/* avoid - not minification-safe*/ angular.module('app').controller('DashboardController', d);function d(a, b) { }   Manually Identify Dependencies [Style Y091]  Use $inject to manually identify your dependencies for Angular components.\nWhy?: This technique mirrors the technique used by ng-annotate, which I recommend for automating the creation of minification safe dependencies. If ng-annotate detects injection has already been made, it will not duplicate it.\nWhy?: This safeguards your dependencies from being vulnerable to minification issues when parameters may be mangled. For example, common and dataservice may become a or b and not be found by Angular.\nWhy?: Avoid creating in-line dependencies as long lists can be difficult to read in the array. Also it can be confusing that the array is a series of strings while the last item is the component\u0026rsquo;s function.\n/* avoid */ angular .module('app') .controller('DashboardController', ['$location', '$routeParams', 'common', 'dataservice', function Dashboard($location, $routeParams, common, dataservice) {} ]);  /* avoid */ angular .module('app') .controller('DashboardController', ['$location', '$routeParams', 'common', 'dataservice', Dashboard]); function Dashboard($location, $routeParams, common, dataservice) { }  /* recommended */ angular .module('app') .controller('DashboardController', DashboardController); DashboardController.$inject = ['$location', '$routeParams', 'common', 'dataservice']; function DashboardController($location, $routeParams, common, dataservice) { }  Note: When your function is below a return statement the $inject may be unreachable (this may happen in a directive). You can solve this by moving the Controller outside of the directive.\n/* avoid */ // inside a directive definition function outer() { var ddo = { controller: DashboardPanelController, controllerAs: 'vm' }; return ddo; DashboardPanelController.$inject = ['logger']; // Unreachable function DashboardPanelController(logger) { } }  /* recommended */ // outside a directive definition function outer() { var ddo = { controller: DashboardPanelController, controllerAs: 'vm' }; return ddo; } DashboardPanelController.$inject = ['logger']; function DashboardPanelController(logger) { }   Manually Identify Route Resolver Dependencies [Style Y092]  Use $inject to manually identify your route resolver dependencies for Angular components.\nWhy?: This technique breaks out the anonymous function for the route resolver, making it easier to read.\nWhy?: An $inject statement can easily precede the resolver to handle making any dependencies minification safe.\n/* recommended */ function config($routeProvider) { $routeProvider .when('/avengers', { templateUrl: 'avengers.html', controller: 'AvengersController', controllerAs: 'vm', resolve: { moviesPrepService: moviesPrepService } }); } moviesPrepService.$inject = ['movieService']; function moviesPrepService(movieService) { return movieService.getMovies(); }   Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/parentheses/",
	"title": "Parentheses",
	"tags": [],
	"description": "",
	"content": " Parentheses  Wrap JSX tags in parentheses when they span more than one line. eslint: react/jsx-wrap-multilines\n// bad render() { return \u0026lt;MyComponent className=\u0026quot;long body\u0026quot; foo=\u0026quot;bar\u0026quot;\u0026gt; \u0026lt;MyChild /\u0026gt; \u0026lt;/MyComponent\u0026gt;; } // good render() { return ( \u0026lt;MyComponent className=\u0026quot;long body\u0026quot; foo=\u0026quot;bar\u0026quot;\u0026gt; \u0026lt;MyChild /\u0026gt; \u0026lt;/MyComponent\u0026gt; ); } // good, when single line render() { const body = \u0026lt;div\u0026gt;hello\u0026lt;/div\u0026gt;; return \u0026lt;MyComponent\u0026gt;{body}\u0026lt;/MyComponent\u0026gt;; }   "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/minification-and-annotation/",
	"title": "Minification and Annotation",
	"tags": [],
	"description": "",
	"content": " Minification and Annotation ng-annotate [Style Y100]  Use ng-annotate for Gulp or Grunt and comment functions that need automated dependency injection using /* @ngInject */\nWhy?: This safeguards your code from any dependencies that may not be using minification-safe practices.\nWhy?: ng-min is deprecated\n I prefer Gulp as I feel it is easier to write, to read, and to debug.\n The following code is not using minification safe dependencies.\nangular .module('app') .controller('AvengersController', AvengersController); /* @ngInject */ function AvengersController(storage, avengerService) { var vm = this; vm.heroSearch = ''; vm.storeHero = storeHero; function storeHero() { var hero = avengerService.find(vm.heroSearch); storage.save(hero.name, hero); } }  When the above code is run through ng-annotate it will produce the following output with the $inject annotation and become minification-safe.\nangular .module('app') .controller('AvengersController', AvengersController); /* @ngInject */ function AvengersController(storage, avengerService) { var vm = this; vm.heroSearch = ''; vm.storeHero = storeHero; function storeHero() { var hero = avengerService.find(vm.heroSearch); storage.save(hero.name, hero); } } AvengersController.$inject = ['storage', 'avengerService'];  Note: If ng-annotate detects injection has already been made (e.g. @ngInject was detected), it will not duplicate the $inject code.\nNote: When using a route resolver you can prefix the resolver\u0026rsquo;s function with /* @ngInject */ and it will produce properly annotated code, keeping any injected dependencies minification safe.\n// Using @ngInject annotations function config($routeProvider) { $routeProvider .when('/avengers', { templateUrl: 'avengers.html', controller: 'AvengersController', controllerAs: 'vm', resolve: { /* @ngInject */ moviesPrepService: function(movieService) { return movieService.getMovies(); } } }); }   Note: Starting from Angular 1.3 you can use the ngApp directive\u0026rsquo;s ngStrictDi parameter to detect any potentially missing minification safe dependencies. When present the injector will be created in \u0026ldquo;strict-di\u0026rdquo; mode causing the application to fail to invoke functions which do not use explicit function annotation (these may not be minification safe). Debugging info will be logged to the console to help track down the offending code. I prefer to only use ng-strict-di for debugging purposes only. \u0026lt;body ng-app=\u0026quot;APP\u0026quot; ng-strict-di\u0026gt;\n  Use Gulp or Grunt for ng-annotate [Style Y101]  Use gulp-ng-annotate or grunt-ng-annotate in an automated build task. Inject /* @ngInject */ prior to any function that has dependencies.\nWhy?: ng-annotate will catch most dependencies, but it sometimes requires hints using the /* @ngInject */ syntax.\nThe following code is an example of a gulp task using ngAnnotate\ngulp.task('js', ['jshint'], function() { var source = pkg.paths.js; return gulp.src(source) .pipe(sourcemaps.init()) .pipe(concat('all.min.js', {newLine: ';'})) // Annotate before uglify so the code get's min'd properly. .pipe(ngAnnotate({ // true helps add where @ngInject is not used. It infers. // Doesn't work with resolve, so we must be explicit there add: true })) .pipe(bytediff.start()) .pipe(uglify({mangle: true})) .pipe(bytediff.stop()) .pipe(sourcemaps.write('./')) .pipe(gulp.dest(pkg.paths.dev)); });   Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": " Tags  Always self-close tags that have no children. eslint: react/self-closing-comp\n// bad \u0026lt;Foo className=\u0026quot;stuff\u0026quot;\u0026gt;\u0026lt;/Foo\u0026gt; // good \u0026lt;Foo className=\u0026quot;stuff\u0026quot; /\u0026gt;  If your component has multi-line properties, close its tag on a new line. eslint: react/jsx-closing-bracket-location\n// bad \u0026lt;Foo bar=\u0026quot;bar\u0026quot; baz=\u0026quot;baz\u0026quot; /\u0026gt; // good \u0026lt;Foo bar=\u0026quot;bar\u0026quot; baz=\u0026quot;baz\u0026quot; /\u0026gt;   "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/exception-handling/",
	"title": "Exception Handling",
	"tags": [],
	"description": "",
	"content": " Exception Handling decorators [Style Y110]  Use a decorator, at config time using the $provide service, on the $exceptionHandler service to perform custom actions when exceptions occur.\nWhy?: Provides a consistent way to handle uncaught Angular exceptions for development-time or run-time.\nNote: Another option is to override the service instead of using a decorator. This is a fine option, but if you want to keep the default behavior and extend it a decorator is recommended.\n/* recommended */ angular .module('blocks.exception') .config(exceptionConfig); exceptionConfig.$inject = ['$provide']; function exceptionConfig($provide) { $provide.decorator('$exceptionHandler', extendExceptionHandler); } extendExceptionHandler.$inject = ['$delegate', 'toastr']; function extendExceptionHandler($delegate, toastr) { return function(exception, cause) { $delegate(exception, cause); var errorData = { exception: exception, cause: cause }; /** * Could add the error to a service's collection, * add errors to $rootScope, log errors to remote web server, * or log locally. Or throw hard. It is entirely up to you. * throw exception; */ toastr.error(exception.msg, errorData); }; }   Exception Catchers [Style Y111]  Create a factory that exposes an interface to catch and gracefully handle exceptions.\nWhy?: Provides a consistent way to catch exceptions that may be thrown in your code (e.g. during XHR calls or promise failures).\nNote: The exception catcher is good for catching and reacting to specific exceptions from calls that you know may throw one. For example, when making an XHR call to retrieve data from a remote web service and you want to catch any exceptions from that service and react uniquely.\n/* recommended */ angular .module('blocks.exception') .factory('exception', exception); exception.$inject = ['logger']; function exception(logger) { var service = { catcher: catcher }; return service; function catcher(message) { return function(reason) { logger.error(message, reason); }; } }   Route Errors [Style Y112]  Handle and log all routing errors using $routeChangeError.\nWhy?: Provides a consistent way to handle all routing errors.\nWhy?: Potentially provides a better user experience if a routing error occurs and you route them to a friendly screen with more details or recovery options.\n/* recommended */ var handlingRouteChangeError = false; function handleRoutingErrors() { /** * Route cancellation: * On routing error, go to the dashboard. * Provide an exit clause if it tries to do it twice. */ $rootScope.$on('$routeChangeError', function(event, current, previous, rejection) { if (handlingRouteChangeError) { return; } handlingRouteChangeError = true; var destination = (current \u0026amp;\u0026amp; (current.title || current.name || current.loadedTemplateUrl)) || 'unknown target'; var msg = 'Error routing to ' + destination + '. ' + (rejection.msg || ''); /** * Optionally log using a custom service or $log. * (Don't forget to inject custom service) */ logger.warning(msg, [current]); /** * On routing error, go to another route/state. */ $location.path('/'); } ); }   Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/methods/",
	"title": "Methods",
	"tags": [],
	"description": "",
	"content": " Methods  Use arrow functions to close over local variables.\nfunction ItemList(props) { return ( \u0026lt;ul\u0026gt; {props.items.map((item, index) =\u0026gt; ( \u0026lt;Item key={item.key} onClick={() =\u0026gt; doSomethingWith(item.name, index)} /\u0026gt; ))} \u0026lt;/ul\u0026gt; ); }  Bind event handlers for the render method in the constructor. eslint: react/jsx-no-bind\n Why? A bind call in the render path creates a brand new function on every single render.\n // bad class extends React.Component { onClickDiv() { // do stuff } render() { return \u0026lt;div onClick={this.onClickDiv.bind(this)} /\u0026gt;; } } // good class extends React.Component { constructor(props) { super(props); this.onClickDiv = this.onClickDiv.bind(this); } onClickDiv() { // do stuff } render() { return \u0026lt;div onClick={this.onClickDiv} /\u0026gt;; } }  Do not use underscore prefix for internal methods of a React component. \u0026gt; Why? Underscore prefixes are sometimes used as a convention in other languages to denote privacy. But, unlike those languages, there is no native support for privacy in JavaScript, everything is public. Regardless of your intentions, adding underscore prefixes to your properties does not actually make them private, and any property (underscore-prefixed or not) should be treated as being public. See issues #1024, and #490 for a more in-depth discussion.\n// bad React.createClass({ _onClickSubmit() { // do stuff }, // other stuff }); // good class extends React.Component { onClickSubmit() { // do stuff } // other stuff }  Be sure to return a value in your render methods. eslint: react/require-render-return\n// bad render() { (\u0026lt;div /\u0026gt;); } // good render() { return (\u0026lt;div /\u0026gt;); }   "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/naming/",
	"title": "Naming",
	"tags": [],
	"description": "",
	"content": " Naming Naming Guidelines [Style Y120]  Use consistent names for all components following a pattern that describes the component\u0026rsquo;s feature then (optionally) its type. My recommended pattern is feature.type.js. There are 2 names for most assets:\n the file name (avengers.controller.js) the registered component name with Angular (AvengersController)  Why?: Naming conventions help provide a consistent way to find content at a glance. Consistency within the project is vital. Consistency with a team is important. Consistency across a company provides tremendous efficiency.\nWhy?: The naming conventions should simply help you find your code faster and make it easier to understand.\n  Feature File Names [Style Y121]  Use consistent names for all components following a pattern that describes the component\u0026rsquo;s feature then (optionally) its type. My recommended pattern is feature.type.js.\nWhy?: Provides a consistent way to quickly identify components.\nWhy?: Provides pattern matching for any automated tasks.\n  /** * common options */ // Controllers avengers.js avengers.controller.js avengersController.js // Services/Factories logger.js logger.service.js loggerService.js  /** * recommended */ // controllers avengers.controller.js avengers.controller.spec.js // services/factories logger.service.js logger.service.spec.js // constants constants.js // module definition avengers.module.js // routes avengers.routes.js avengers.routes.spec.js // configuration avengers.config.js // directives avenger-profile.directive.js avenger-profile.directive.spec.js  Note: Another common convention is naming controller files without the word controller in the file name such as avengers.js instead of avengers.controller.js. All other conventions still hold using a suffix of the type. Controllers are the most common type of component so this just saves typing and is still easily identifiable. I recommend you choose 1 convention and be consistent for your team. My preference is avengers.controller.js identifying the AvengersController.\n/** * recommended */ // Controllers avengers.js avengers.spec.js  Test File Names [Style Y122]  Name test specifications similar to the component they test with a suffix of spec.\nWhy?: Provides a consistent way to quickly identify components.\nWhy?: Provides pattern matching for karma or other test runners.\n  /** * recommended */ avengers.controller.spec.js logger.service.spec.js avengers.routes.spec.js avenger-profile.directive.spec.js  Controller Names [Style Y123]  Use consistent names for all controllers named after their feature. Use UpperCamelCase for controllers, as they are constructors.\nWhy?: Provides a consistent way to quickly identify and reference controllers.\nWhy?: UpperCamelCase is conventional for identifying object that can be instantiated using a constructor.\n  /** * recommended */ // avengers.controller.js angular .module .controller('HeroAvengersController', HeroAvengersController); function HeroAvengersController() { }  Controller Name Suffix [Style Y124]  Append the controller name with the suffix Controller.\nWhy?: The Controller suffix is more commonly used and is more explicitly descriptive.\n  /** * recommended */ // avengers.controller.js angular .module .controller('AvengersController', AvengersController); function AvengersController() { }  Factory and Service Names [Style Y125]  Use consistent names for all factories and services named after their feature. Use camel-casing for services and factories. Avoid prefixing factories and services with $. Only suffix service and factories with Service when it is not clear what they are (i.e. when they are nouns).\nWhy?: Provides a consistent way to quickly identify and reference factories.\nWhy?: Avoids name collisions with built-in factories and services that use the $ prefix.\nWhy?: Clear service names such as logger do not require a suffix.\nWhy?: Service names such as avengers are nouns and require a suffix and should be named avengersService.\n  /** * recommended */ // logger.service.js angular .module .factory('logger', logger); function logger() { }  /** * recommended */ // credit.service.js angular .module .factory('creditService', creditService); function creditService() { } // customer.service.js angular .module .service('customerService', customerService); function customerService() { }  Directive Component Names [Style Y126]  Use consistent names for all directives using camelCase. Use a short prefix to describe the area that the directives belong (some example are company prefix or project prefix).\nWhy?: Provides a consistent way to quickly identify and reference components.\n  /** * recommended */ // avenger-profile.directive.js angular .module .directive('xxAvengerProfile', xxAvengerProfile); // usage is \u0026lt;xx-avenger-profile\u0026gt; \u0026lt;/xx-avenger-profile\u0026gt; function xxAvengerProfile() { }  Modules [Style Y127]  When there are multiple modules, the main module file is named app.module.js while other dependent modules are named after what they represent. For example, an admin module is named admin.module.js. The respective registered module names would be app and admin.\nWhy?: Provides consistency for multiple module apps, and for expanding to large applications.\nWhy?: Provides easy way to use task automation to load all module definitions first, then all other angular files (for bundling).\n  Configuration [Style Y128]  Separate configuration for a module into its own file named after the module. A configuration file for the main app module is named app.config.js (or simply config.js). A configuration for a module named admin.module.js is named admin.config.js.\nWhy?: Separates configuration from module definition, components, and active code.\nWhy?: Provides an identifiable place to set configuration for a module.\n  Routes [Style Y129]  Separate route configuration into its own file. Examples might be app.route.js for the main module and admin.route.js for the admin module. Even in smaller apps I prefer this separation from the rest of the configuration.  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/ordering/",
	"title": "Ordering",
	"tags": [],
	"description": "",
	"content": " Ordering  Ordering for class extends React.Component:   optional static methods constructor getChildContext componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount clickHandlers or eventHandlers like onClickSubmit() or onChangeDescription() getter methods for render like getSelectReason() or getFooterContent() optional render methods like renderNavigation() or renderProfilePicture() render   How to define propTypes, defaultProps, contextTypes, etc\u0026hellip;\nimport React from 'react'; import PropTypes from 'prop-types'; const propTypes = { id: PropTypes.number.isRequired, url: PropTypes.string.isRequired, text: PropTypes.string, }; const defaultProps = { text: 'Hello World', }; class Link extends React.Component { static methodsAreOk() { return true; } render() { return \u0026lt;a href={this.props.url} data-id={this.props.id}\u0026gt;{this.props.text}\u0026lt;/a\u0026gt;; } } Link.propTypes = propTypes; Link.defaultProps = defaultProps; export default Link;  Ordering for React.createClass: eslint: react/sort-comp\n   displayName propTypes contextTypes childContextTypes mixins statics defaultProps getDefaultProps getInitialState getChildContext componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount clickHandlers or eventHandlers like onClickSubmit() or onChangeDescription() getter methods for render like getSelectReason() or getFooterContent() optional render methods like renderNavigation() or renderProfilePicture() render  "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/application-structure-lift-principle/",
	"title": "Application Structure Lift Principle",
	"tags": [],
	"description": "",
	"content": " Application Structure LIFT Principle LIFT [Style Y140]  Structure your app such that you can Locate your code quickly, Identify the code at a glance, keep the Flattest structure you can, and Try to stay DRY. The structure should follow these 4 basic guidelines.\nWhy LIFT?: Provides a consistent structure that scales well, is modular, and makes it easier to increase developer efficiency by finding code quickly. Another way to check your app structure is to ask yourself: How quickly can you open and work in all of the related files for a feature?\nWhen I find my structure is not feeling comfortable, I go back and revisit these LIFT guidelines\n Locating our code is easy Identify code at a glance Flat structure as long as we can Try to stay DRY (Don’t Repeat Yourself) or T-DRY   Locate [Style Y141]  Make locating your code intuitive, simple and fast.\nWhy?: I find this to be super important for a project. If the team cannot find the files they need to work on quickly, they will not be able to work as efficiently as possible, and the structure needs to change. You may not know the file name or where its related files are, so putting them in the most intuitive locations and near each other saves a ton of time. A descriptive folder structure can help with this.\n/bower_components /client /app /avengers /blocks /exception /logger /core /dashboard /data /layout /widgets /content index.html .bower.json   Identify [Style Y142]  When you look at a file you should instantly know what it contains and represents.\nWhy?: You spend less time hunting and pecking for code, and become more efficient. If this means you want longer file names, then so be it. Be descriptive with file names and keeping the contents of the file to exactly 1 component. Avoid files with multiple controllers, multiple services, or a mixture. There are deviations of the 1 per file rule when I have a set of very small features that are all related to each other, they are still easily identifiable.\n  Flat [Style Y143]  Keep a flat folder structure as long as possible. When you get to 7+ files, begin considering separation.\nWhy?: Nobody wants to search 7 levels of folders to find a file. Think about menus on web sites … anything deeper than 2 should take serious consideration. In a folder structure there is no hard and fast number rule, but when a folder has 7-10 files, that may be time to create subfolders. Base it on your comfort level. Use a flatter structure until there is an obvious value (to help the rest of LIFT) in creating a new folder.\n  T-DRY (Try to Stick to DRY) [Style Y144]  Be DRY, but don\u0026rsquo;t go nuts and sacrifice readability.\nWhy?: Being DRY is important, but not crucial if it sacrifices the others in LIFT, which is why I call it T-DRY. I don’t want to type session-view.html for a view because, well, it’s obviously a view. If it is not obvious or by convention, then I name it.\n  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/ismounted/",
	"title": "Ismounted",
	"tags": [],
	"description": "",
	"content": " isMounted  Do not use isMounted. eslint: react/no-is-mounted   Why? isMounted is an anti-pattern, is not available when using ES6 classes, and is on its way to being officially deprecated.\n "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/application-structure/",
	"title": "Application Structure",
	"tags": [],
	"description": "",
	"content": " Application Structure Overall Guidelines [Style Y150]  Have a near term view of implementation and a long term vision. In other words, start small but keep in mind on where the app is heading down the road. All of the app\u0026rsquo;s code goes in a root folder named app. All content is 1 feature per file. Each controller, service, module, view is in its own file. All 3rd party vendor scripts are stored in another root folder and not in the app folder. I didn\u0026rsquo;t write them and I don\u0026rsquo;t want them cluttering my app (bower_components, scripts, lib).\nNote: Find more details and reasoning behind the structure at this original post on application structure.\n  Layout [Style Y151]  Place components that define the overall layout of the application in a folder named layout. These may include a shell view and controller may act as the container for the app, navigation, menus, content areas, and other regions.\nWhy?: Organizes all layout in a single place re-used throughout the application.\n  Folders-by-Feature Structure [Style Y152]  Create folders named for the feature they represent. When a folder grows to contain more than 7 files, start to consider creating a folder for them. Your threshold may be different, so adjust as needed.\nWhy?: A developer can locate the code, identify what each file represents at a glance, the structure is flat as can be, and there is no repetitive nor redundant names.\nWhy?: The LIFT guidelines are all covered.\nWhy?: Helps reduce the app from becoming cluttered through organizing the content and keeping them aligned with the LIFT guidelines.\nWhy?: When there are a lot of files (10+) locating them is easier with a consistent folder structures and more difficult in flat structures.\n```javascript /**\n recommended */  app/ app.module.js app.config.js components/ calendar.directive.js calendar.directive.html user-profile.directive.js user-profile.directive.html layout/ shell.html shell.controller.js topnav.html topnav.controller.js people/ attendees.html attendees.controller.js people.routes.js speakers.html speakers.controller.js speaker-detail.html speaker-detail.controller.js services/ data.service.js localstorage.service.js logger.service.js spinner.service.js sessions/ sessions.html sessions.controller.js sessions.routes.js session-detail.html session-detail.controller.js\n ![Sample App Structure](https://raw.githubusercontent.com/johnpapa/angular-styleguide/master/a1/assets/modularity-2.png) Note: Do not structure your app using folders-by-type. This requires moving to multiple folders when working on a feature and gets unwieldy quickly as the app grows to 5, 10 or 25+ views and controllers (and other features), which makes it more difficult than folder-by-feature to locate files. ```javascript /* * avoid * Alternative folders-by-type. * I recommend \u0026quot;folders-by-feature\u0026quot;, instead. */ app/ app.module.js app.config.js app.routes.js directives.js controllers/ attendees.js session-detail.js sessions.js shell.js speakers.js speaker-detail.js topnav.js directives/ calendar.directive.js calendar.directive.html user-profile.directive.js user-profile.directive.html services/ dataservice.js localstorage.js logger.js spinner.js views/ attendees.html session-detail.html sessions.html shell.html speakers.html speaker-detail.html topnav.html   Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/modularity/",
	"title": "Modularity",
	"tags": [],
	"description": "",
	"content": " Modularity Many Small, Self Contained Modules [Style Y160]  Create small modules that encapsulate one responsibility.\nWhy?: Modular applications make it easy to plug and go as they allow the development teams to build vertical slices of the applications and roll out incrementally. This means we can plug in new features as we develop them.\n  Create an App Module [Style Y161]  Create an application root module whose role is to pull together all of the modules and features of your application. Name this for your application.\nWhy?: Angular encourages modularity and separation patterns. Creating an application root module whose role is to tie your other modules together provides a very straightforward way to add or remove modules from your application.\n  Keep the App Module Thin [Style Y162]  Only put logic for pulling together the app in the application module. Leave features in their own modules.\nWhy?: Adding additional roles to the application root to get remote data, display views, or other logic not related to pulling the app together muddies the app module and make both sets of features harder to reuse or turn off.\nWhy?: The app module becomes a manifest that describes which modules help define the application.\n  Feature Areas are Modules [Style Y163]  Create modules that represent feature areas, such as layout, reusable and shared services, dashboards, and app specific features (e.g. customers, admin, sales).\nWhy?: Self contained modules can be added to the application with little or no friction.\nWhy?: Sprints or iterations can focus on feature areas and turn them on at the end of the sprint or iteration.\nWhy?: Separating feature areas into modules makes it easier to test the modules in isolation and reuse code.\n  Reusable Blocks are Modules [Style Y164]  Create modules that represent reusable application blocks for common services such as exception handling, logging, diagnostics, security, and local data stashing.\nWhy?: These types of features are needed in many applications, so by keeping them separated in their own modules they can be application generic and be reused across applications.\n  Module Dependencies [Style Y165]  The application root module depends on the app specific feature modules and any shared or reusable modules.\nWhy?: The main app module contains a quickly identifiable manifest of the application\u0026rsquo;s features.\nWhy?: Each feature area contains a manifest of what it depends on, so it can be pulled in as a dependency in other applications and still work.\nWhy?: Intra-App features such as shared data services become easy to locate and share from within app.core (choose your favorite name for this module).\nNote: This is a strategy for consistency. There are many good options here. Choose one that is consistent, follows Angular\u0026rsquo;s dependency rules, and is easy to maintain and scale.\n My structures vary slightly between projects but they all follow these guidelines for structure and modularity. The implementation may vary depending on the features and the team. In other words, don\u0026rsquo;t get hung up on an exact like-for-like structure but do justify your structure using consistency, maintainability, and efficiency in mind.\nIn a small app, you can also consider putting all the shared dependencies in the app module where the feature modules have no direct dependencies. This makes it easier to maintain the smaller application, but makes it harder to reuse modules outside of this application.\n  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/startup-logic/",
	"title": "Startuplogic",
	"tags": [],
	"description": "",
	"content": " Startup Logic Configuration [Style Y170]  Inject code into module configuration that must be configured before running the angular app. Ideal candidates include providers and constants.\nWhy?: This makes it easier to have less places for configuration.\n  angular .module('app') .config(configure); configure.$inject = ['routerHelperProvider', 'exceptionHandlerProvider', 'toastr']; function configure (routerHelperProvider, exceptionHandlerProvider, toastr) { exceptionHandlerProvider.configure(config.appErrorPrefix); configureStateHelper(); toastr.options.timeOut = 4000; toastr.options.positionClass = 'toast-bottom-right'; //////////////// function configureStateHelper() { routerHelperProvider.configure({ docTitle: 'NG-Modular: ' }); } }  Run Blocks [Style Y171]  Any code that needs to run when an application starts should be declared in a factory, exposed via a function, and injected into the run block.\n Consider using manual bootstrapping techniques, as an alternative for logic that must run prior to running the Angular app.\nWhy?: Code directly in a run block can be difficult to test. Placing in a factory makes it easier to abstract and mock.\nWhy?: Code directly in a run block can cause race conditions for startup logic, as it does not have a way to communicate when asynchronous code in the run block has completed.\n  angular .module('app') .run(runBlock); runBlock.$inject = ['authenticator', 'translator']; function runBlock(authenticator, translator) { authenticator.initialize(); translator.initialize(); }  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/angular-wrapper-services/",
	"title": "Angular $ Wrapper Services",
	"tags": [],
	"description": "",
	"content": " Angular $ Wrapper Services $document and $window [Style Y180]  Use $document and $window instead of document and window.\nWhy?: These services are wrapped by Angular and more easily testable than using document and window in tests. This helps you avoid having to mock document and window yourself.\n  $timeout and $interval [Style Y181]  Use $timeout and $interval instead of setTimeout and setInterval .\nWhy?: These services are wrapped by Angular and more easily testable and handle Angular\u0026rsquo;s digest cycle thus keeping data binding in sync.\n  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/testing/",
	"title": "Testing",
	"tags": [],
	"description": "",
	"content": " Testing Unit testing helps maintain clean code, as such I included some of my recommendations for unit testing foundations with links for more information.\nWrite Tests with Stories [Style Y190]  Write a set of tests for every story. Start with an empty test and fill them in as you write the code for the story.\nWhy?: Writing the test descriptions helps clearly define what your story will do, will not do, and how you can measure success.\nit('should have Avengers controller', function() { // TODO }); it('should find 1 Avenger when filtered by name', function() { // TODO }); it('should have 10 Avengers', function() { // TODO (mock data?) }); it('should return Avengers via XHR', function() { // TODO ($httpBackend?) }); // and so on   Testing Library [Style Y191]  Use Jasmine or Mocha for unit testing.\nWhy?: Both Jasmine and Mocha are widely used in the Angular community. Both are stable, well maintained, and provide robust testing features.\nNote: When using Mocha, also consider choosing an assert library such as Chai. I prefer Mocha.\n  Test Runner [Style Y192]  Use Karma as a test runner.\nWhy?: Karma is easy to configure to run once or automatically when you change your code.\nWhy?: Karma hooks into your Continuous Integration process easily on its own or through Grunt or Gulp.\nWhy?: Some IDE\u0026rsquo;s are beginning to integrate with Karma, such as WebStorm and Visual Studio.\nWhy?: Karma works well with task automation leaders such as Grunt (with grunt-karma) and Gulp. When using Gulp, use Karma directly and not with a plugin as the API can be called directly.\n/* recommended */ // Gulp example with Karma directly function startTests(singleRun, done) { var child; var excludeFiles = []; var fork = require('child_process').fork; var Server = require('karma').Server; var serverSpecs = config.serverIntegrationSpecs; if (args.startServers) { log('Starting servers'); var savedEnv = process.env; savedEnv.NODE_ENV = 'dev'; savedEnv.PORT = 8888; child = fork(config.nodeServer); } else { if (serverSpecs \u0026amp;\u0026amp; serverSpecs.length) { excludeFiles = serverSpecs; } } var karmaOptions = { configFile: __dirname + '/karma.conf.js', exclude: excludeFiles, singleRun: !!singleRun }; let server = new Server(karmaOptions, karmaCompleted); server.start(); //////////////// function karmaCompleted(karmaResult) { log('Karma completed'); if (child) { log('shutting down the child process'); child.kill(); } if (karmaResult === 1) { done('karma: tests failed with code ' + karmaResult); } else { done(); } } }   Stubbing and Spying [Style Y193]  Use Sinon for stubbing and spying.\nWhy?: Sinon works well with both Jasmine and Mocha and extends the stubbing and spying features they offer.\nWhy?: Sinon makes it easier to toggle between Jasmine and Mocha, if you want to try both.\nWhy?: Sinon has descriptive messages when tests fail the assertions.\n  Headless Browser [Style Y194]  Use PhantomJS to run your tests on a server.\nWhy?: PhantomJS is a headless browser that helps run your tests without needing a \u0026ldquo;visual\u0026rdquo; browser. So you do not have to install Chrome, Safari, IE, or other browsers on your server.\nNote: You should still test on all browsers in your environment, as appropriate for your target audience.\n  Code Analysis [Style Y195]  Run JSHint on your tests.\nWhy?: Tests are code. JSHint can help identify code quality issues that may cause the test to work improperly.\n  Alleviate Globals for JSHint Rules on Tests [Style Y196]  Relax the rules on your test code to allow for common globals such as describe and expect. Relax the rules for expressions, as Mocha uses these.\nWhy?: Your tests are code and require the same attention and code quality rules as all of your production code. However, global variables used by the testing framework, for example, can be relaxed by including this in your test specs.\n/* jshint -W117, -W030 */  Or you can add the following to your JSHint Options file.\n\u0026quot;jasmine\u0026quot;: true, \u0026quot;mocha\u0026quot;: true,   Organizing Tests [Style Y197]  Place unit test files (specs) side-by-side with your client code. Place specs that cover server integration or test multiple components in a separate tests folder.\nWhy?: Unit tests have a direct correlation to a specific component and file in source code.\nWhy?: It is easier to keep them up to date since they are always in sight. When coding whether you do TDD or test during development or test after development, the specs are side-by-side and never out of sight nor mind, and thus more likely to be maintained which also helps maintain code coverage.\nWhy?: When you update source code it is easier to go update the tests at the same time.\nWhy?: Placing them side-by-side makes it easy to find them and easy to move them with the source code if you move the source.\nWhy?: Having the spec nearby makes it easier for the source code reader to learn how the component is supposed to be used and to discover its known limitations.\nWhy?: Separating specs so they are not in a distributed build is easy with grunt or gulp.\n/src/client/app/customers/customer-detail.controller.js /customer-detail.controller.spec.js /customers.controller.js /customers.controller.spec.js /customers.module.js /customers.route.js /customers.route.spec.js   Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/animations/",
	"title": "Animations",
	"tags": [],
	"description": "",
	"content": " Animations Usage [Style Y210]  Use subtle animations with Angular to transition between states for views and primary visual elements. Include the ngAnimate module. The 3 keys are subtle, smooth, seamless.\nWhy?: Subtle animations can improve User Experience when used appropriately.\nWhy?: Subtle animations can improve perceived performance as views transition.\n  Sub Second [Style Y211]  Use short durations for animations. I generally start with 300ms and adjust until appropriate.\nWhy?: Long animations can have the reverse effect on User Experience and perceived performance by giving the appearance of a slow application.\n  animate.css [Style Y212]  Use animate.css for conventional animations.\nWhy?: The animations that animate.css provides are fast, smooth, and easy to add to your application.\nWhy?: Provides consistency in your animations.\nWhy?: animate.css is widely used and tested.\nNote: See this great post by Matias Niemelä on Angular animations\n  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/comments/",
	"title": "Comments",
	"tags": [],
	"description": "",
	"content": " Comments jsDoc [Style Y220]  If planning to produce documentation, use jsDoc syntax to document function names, description, params and returns. Use @namespace and @memberOf to match your app structure.\nWhy?: You can generate (and regenerate) documentation from your code, instead of writing it from scratch.\nWhy?: Provides consistency using a common industry tool.\n  /** * Logger Factory * @namespace Factories */ (function() { angular .module('app') .factory('logger', logger); /** * @namespace Logger * @desc Application wide logger * @memberOf Factories */ function logger($log) { var service = { logError: logError }; return service; //////////// s /** * @name logError * @desc Logs errors * @param {String} msg Message to log * @returns {String} * @memberOf Factories.Logger */ function logError(msg) { var loggedMsg = 'Error: ' + msg; $log.error(loggedMsg); return loggedMsg; }; } })();  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/jshint/",
	"title": "JShint",
	"tags": [],
	"description": "",
	"content": " JS Hint Use an Options File [Style Y230]  Use JS Hint for linting your JavaScript and be sure to customize the JS Hint options file and include in source control. See the JS Hint docs for details on the options.\nWhy?: Provides a first alert prior to committing any code to source control.\nWhy?: Provides consistency across your team.\n{ \u0026quot;bitwise\u0026quot;: true, \u0026quot;camelcase\u0026quot;: true, \u0026quot;curly\u0026quot;: true, \u0026quot;eqeqeq\u0026quot;: true, \u0026quot;esversion\u0026quot;: 6, \u0026quot;forin\u0026quot;: true, \u0026quot;freeze\u0026quot;: true, \u0026quot;immed\u0026quot;: true, \u0026quot;indent\u0026quot;: 4, \u0026quot;latedef\u0026quot;: \u0026quot;nofunc\u0026quot;, \u0026quot;newcap\u0026quot;: true, \u0026quot;noarg\u0026quot;: true, \u0026quot;noempty\u0026quot;: true, \u0026quot;nonbsp\u0026quot;: true, \u0026quot;nonew\u0026quot;: true, \u0026quot;plusplus\u0026quot;: false, \u0026quot;quotmark\u0026quot;: \u0026quot;single\u0026quot;, \u0026quot;undef\u0026quot;: true, \u0026quot;unused\u0026quot;: false, \u0026quot;strict\u0026quot;: false, \u0026quot;maxparams\u0026quot;: 10, \u0026quot;maxdepth\u0026quot;: 5, \u0026quot;maxstatements\u0026quot;: 40, \u0026quot;maxcomplexity\u0026quot;: 8, \u0026quot;maxlen\u0026quot;: 120, \u0026quot;asi\u0026quot;: false, \u0026quot;boss\u0026quot;: false, \u0026quot;debug\u0026quot;: false, \u0026quot;eqnull\u0026quot;: true, \u0026quot;esnext\u0026quot;: false, \u0026quot;evil\u0026quot;: false, \u0026quot;expr\u0026quot;: false, \u0026quot;funcscope\u0026quot;: false, \u0026quot;globalstrict\u0026quot;: false, \u0026quot;iterator\u0026quot;: false, \u0026quot;lastsemic\u0026quot;: false, \u0026quot;laxbreak\u0026quot;: false, \u0026quot;laxcomma\u0026quot;: false, \u0026quot;loopfunc\u0026quot;: true, \u0026quot;maxerr\u0026quot;: 50, \u0026quot;moz\u0026quot;: false, \u0026quot;multistr\u0026quot;: false, \u0026quot;notypeof\u0026quot;: false, \u0026quot;proto\u0026quot;: false, \u0026quot;scripturl\u0026quot;: false, \u0026quot;shadow\u0026quot;: false, \u0026quot;sub\u0026quot;: true, \u0026quot;supernew\u0026quot;: false, \u0026quot;validthis\u0026quot;: false, \u0026quot;noyield\u0026quot;: false, \u0026quot;browser\u0026quot;: true, \u0026quot;node\u0026quot;: true, \u0026quot;globals\u0026quot;: { \u0026quot;angular\u0026quot;: false, \u0026quot;$\u0026quot;: false } }   Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/jscs/",
	"title": "JSCS",
	"tags": [],
	"description": "",
	"content": " JSCS Use an Options File [Style Y235]  Use JSCS for checking your coding styles your JavaScript and be sure to customize the JSCS options file and include in source control. See the JSCS docs for details on the options.\nWhy?: Provides a first alert prior to committing any code to source control.\nWhy?: Provides consistency across your team.\n{ \u0026quot;excludeFiles\u0026quot;: [\u0026quot;node_modules/**\u0026quot;, \u0026quot;bower_components/**\u0026quot;], \u0026quot;requireCurlyBraces\u0026quot;: [ \u0026quot;if\u0026quot;, \u0026quot;else\u0026quot;, \u0026quot;for\u0026quot;, \u0026quot;while\u0026quot;, \u0026quot;do\u0026quot;, \u0026quot;try\u0026quot;, \u0026quot;catch\u0026quot; ], \u0026quot;requireOperatorBeforeLineBreak\u0026quot;: true, \u0026quot;requireCamelCaseOrUpperCaseIdentifiers\u0026quot;: true, \u0026quot;maximumLineLength\u0026quot;: { \u0026quot;value\u0026quot;: 100, \u0026quot;allowComments\u0026quot;: true, \u0026quot;allowRegex\u0026quot;: true }, \u0026quot;validateIndentation\u0026quot;: 4, \u0026quot;validateQuoteMarks\u0026quot;: \u0026quot;'\u0026quot;, \u0026quot;disallowMultipleLineStrings\u0026quot;: true, \u0026quot;disallowMixedSpacesAndTabs\u0026quot;: true, \u0026quot;disallowTrailingWhitespace\u0026quot;: true, \u0026quot;disallowSpaceAfterPrefixUnaryOperators\u0026quot;: true, \u0026quot;disallowMultipleVarDecl\u0026quot;: null, \u0026quot;requireSpaceAfterKeywords\u0026quot;: [ \u0026quot;if\u0026quot;, \u0026quot;else\u0026quot;, \u0026quot;for\u0026quot;, \u0026quot;while\u0026quot;, \u0026quot;do\u0026quot;, \u0026quot;switch\u0026quot;, \u0026quot;return\u0026quot;, \u0026quot;try\u0026quot;, \u0026quot;catch\u0026quot; ], \u0026quot;requireSpaceBeforeBinaryOperators\u0026quot;: [ \u0026quot;=\u0026quot;, \u0026quot;+=\u0026quot;, \u0026quot;-=\u0026quot;, \u0026quot;*=\u0026quot;, \u0026quot;/=\u0026quot;, \u0026quot;%=\u0026quot;, \u0026quot;\u0026lt;\u0026lt;=\u0026quot;, \u0026quot;\u0026gt;\u0026gt;=\u0026quot;, \u0026quot;\u0026gt;\u0026gt;\u0026gt;=\u0026quot;, \u0026quot;\u0026amp;=\u0026quot;, \u0026quot;|=\u0026quot;, \u0026quot;^=\u0026quot;, \u0026quot;+=\u0026quot;, \u0026quot;+\u0026quot;, \u0026quot;-\u0026quot;, \u0026quot;*\u0026quot;, \u0026quot;/\u0026quot;, \u0026quot;%\u0026quot;, \u0026quot;\u0026lt;\u0026lt;\u0026quot;, \u0026quot;\u0026gt;\u0026gt;\u0026quot;, \u0026quot;\u0026gt;\u0026gt;\u0026gt;\u0026quot;, \u0026quot;\u0026amp;\u0026quot;, \u0026quot;|\u0026quot;, \u0026quot;^\u0026quot;, \u0026quot;\u0026amp;\u0026amp;\u0026quot;, \u0026quot;||\u0026quot;, \u0026quot;===\u0026quot;, \u0026quot;==\u0026quot;, \u0026quot;\u0026gt;=\u0026quot;, \u0026quot;\u0026lt;=\u0026quot;, \u0026quot;\u0026lt;\u0026quot;, \u0026quot;\u0026gt;\u0026quot;, \u0026quot;!=\u0026quot;, \u0026quot;!==\u0026quot; ], \u0026quot;requireSpaceAfterBinaryOperators\u0026quot;: true, \u0026quot;requireSpacesInConditionalExpression\u0026quot;: true, \u0026quot;requireSpaceBeforeBlockStatements\u0026quot;: true, \u0026quot;requireLineFeedAtFileEnd\u0026quot;: true, \u0026quot;disallowSpacesInsideObjectBrackets\u0026quot;: \u0026quot;all\u0026quot;, \u0026quot;disallowSpacesInsideArrayBrackets\u0026quot;: \u0026quot;all\u0026quot;, \u0026quot;disallowSpacesInsideParentheses\u0026quot;: true, \u0026quot;jsDoc\u0026quot;: { \u0026quot;checkAnnotations\u0026quot;: true, \u0026quot;checkParamNames\u0026quot;: true, \u0026quot;requireParamTypes\u0026quot;: true, \u0026quot;checkReturnTypes\u0026quot;: true, \u0026quot;checkTypes\u0026quot;: true }, \u0026quot;disallowMultipleLineBreaks\u0026quot;: true, \u0026quot;disallowCommaBeforeLineBreak\u0026quot;: null, \u0026quot;disallowDanglingUnderscores\u0026quot;: null, \u0026quot;disallowEmptyBlocks\u0026quot;: null, \u0026quot;disallowTrailingComma\u0026quot;: null, \u0026quot;requireCommaBeforeLineBreak\u0026quot;: null, \u0026quot;requireDotNotation\u0026quot;: null, \u0026quot;requireMultipleVarDecl\u0026quot;: null, \u0026quot;requireParenthesesAroundIIFE\u0026quot;: true }   Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/constants/",
	"title": "Constants",
	"tags": [],
	"description": "",
	"content": " Constants Vendor Globals [Style Y240]  Create an Angular Constant for vendor libraries\u0026rsquo; global variables.\nWhy?: Provides a way to inject vendor libraries that otherwise are globals. This improves code testability by allowing you to more easily know what the dependencies of your components are (avoids leaky abstractions). It also allows you to mock these dependencies, where it makes sense.\n// constants.js /* global toastr:false, moment:false */ (function() { 'use strict'; angular .module('app.core') .constant('toastr', toastr) .constant('moment', moment); })();   [Style Y241]  Use constants for values that do not change and do not come from another service. When constants are used only for a module that may be reused in multiple applications, place constants in a file per module named after the module. Until this is required, keep constants in the main module in a constants.js file.\nWhy?: A value that may change, even infrequently, should be retrieved from a service so you do not have to change the source code. For example, a url for a data service could be placed in a constants but a better place would be to load it from a web service.\nWhy?: Constants can be injected into any angular component, including providers.\nWhy?: When an application is separated into modules that may be reused in other applications, each stand-alone module should be able to operate on its own including any dependent constants.\n// Constants used by the entire app angular .module('app.core') .constant('moment', moment); // Constants used only by the sales module angular .module('app.sales') .constant('events', { ORDER_CREATED: 'event_order_created', INVENTORY_DEPLETED: 'event_inventory_depleted' });   Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/file-templates-and-snippets/",
	"title": "File Templates And Snippets",
	"tags": [],
	"description": "",
	"content": " File Templates and Snippets Use file templates or snippets to help follow consistent styles and patterns. Here are templates and/or snippets for some of the web development editors and IDEs.\nSublime Text [Style Y250]  Angular snippets that follow these styles and guidelines.\n Download the Sublime Angular snippets Place it in your Packages folder Restart Sublime In a JavaScript file type these commands followed by a TAB  ngcontroller // creates an Angular controller ngdirective // creates an Angular directive ngfactory // creates an Angular factory ngmodule // creates an Angular module ngservice // creates an Angular service ngfilter // creates an Angular filter   Visual Studio [Style Y251]  Angular file templates that follow these styles and guidelines can be found at SideWaffle\n Download the SideWaffle Visual Studio extension (vsix file) Run the vsix file Restart Visual Studio   WebStorm [Style Y252]  Angular live templates that follow these styles and guidelines.\n Download the webstorm-angular-live-templates.xml Place it in your templates folder Restart WebStorm In a JavaScript file type these commands followed by a TAB:  // These are full file snippets containing an IIFE ngapp // creates an Angular module setter ngcontroller // creates an Angular controller ngdirective // creates an Angular directive ngfactory // creates an Angular factory ngfilter // creates an Angular filter ngservice // creates an Angular service // These are partial snippets intended to be chained ngconfig // defines a configuration phase function ngmodule // creates an Angular module getter ngroute // defines an Angular ngRoute 'when' definition ngrun // defines a run phase function ngstate // creates an Angular UI Router state definition   Individual templates are also available for download within the webstorm-angular-live-templates folder\nAtom [Style Y253]  Angular snippets that follow these styles and guidelines.\napm install angularjs-styleguide-snippets  or\n Open Atom, then open the Package Manager (Packages -\u0026gt; Settings View -\u0026gt; Install Packages/Themes) Search for the package \u0026lsquo;angularjs-styleguide-snippets\u0026rsquo; Click \u0026lsquo;Install\u0026rsquo; to install the package  In a JavaScript file type these commands followed by a TAB\nngcontroller // creates an Angular controller ngdirective // creates an Angular directive ngfactory // creates an Angular factory ngmodule // creates an Angular module ngservice // creates an Angular service ngfilter // creates an Angular filter   Brackets [Style Y254]  Angular snippets that follow these styles and guidelines.\n Download the Brackets Angular snippets Brackets Extension manager ( File \u0026gt; Extension manager ) Install \u0026lsquo;Brackets Snippets (by edc)\u0026rsquo; Click the light bulb in brackets\u0026rsquo; right gutter Click Settings and then Import Choose the file and select to skip or override Click Start Import  In a JavaScript file type these commands followed by a TAB\n// These are full file snippets containing an IIFE ngcontroller // creates an Angular controller ngdirective // creates an Angular directive ngfactory // creates an Angular factory ngapp // creates an Angular module setter ngservice // creates an Angular service ngfilter // creates an Angular filter // These are partial snippets intended to chained ngmodule // creates an Angular module getter ngstate // creates an Angular UI Router state definition ngconfig // defines a configuration phase function ngrun // defines a run phase function ngwhen // defines an Angular ngRoute 'when' definition ngtranslate // uses $translate service with its promise   vim [Style Y255]  vim snippets that follow these styles and guidelines.\n Download the vim Angular snippets set neosnippet.vim copy snippets to snippet directory  vim UltiSnips snippets that follow these styles and guidelines.\n Download the vim Angular UltiSnips snippets set UltiSnips copy snippets to UltiSnips directory  ngcontroller // creates an Angular controller ngdirective // creates an Angular directive ngfactory // creates an Angular factory ngmodule // creates an Angular module ngservice // creates an Angular service ngfilter // creates an Angular filter   Visual Studio Code [Style Y256]  Visual Studio Code snippets that follow these styles and guidelines.\n Download the VS Code Angular snippets copy snippets to snippet directory, or alternatively copy and paste the snippets into your existing ones  ngcontroller // creates an Angular controller ngdirective // creates an Angular directive ngfactory // creates an Angular factory ngmodule // creates an Angular module ngservice // creates an Angular service   Emacs [Style Y257]  Emacs snippets that follow these styles and guidelines.\n Download the Emacs Angular snippets  Note that yasnippet categorizes snippets by major mode, and there are several Emacs major modes for editing Javascript code. The snippets are in js2-mode, and the other directories contain only a dotfile to reference them there.\n install yasnippet (M-x package-install RET yasnippet RET) copy snippets to snippet directory, or modify your Emacs init to add snippet directory to yas-snippet-dirs  ngcontroller // creates an Angular controller ngdirective // creates an Angular directive ngfactory // creates an Angular factory ngmodule // creates an Angular module ngservice // creates an Angular service ngfilter // creates an Angular filter   Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/yeoman-generator/",
	"title": "Yeoman Generator",
	"tags": [],
	"description": "",
	"content": " Yeoman Generator [Style Y260] You can use the HotTowel yeoman generator to create an app that serves as a starting point for Angular that follows this style guide.\n Install generator-hottowel   npm install -g generator-hottowel   Create a new folder and change directory to it   mkdir myapp cd myapp   Run the generator   yo hottowel helloWorld  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/routing/",
	"title": "Routing",
	"tags": [],
	"description": "",
	"content": " Routing Client-side routing is important for creating a navigation flow between views and composing views that are made of many smaller templates and directives.\n[Style Y270]  Use the AngularUI Router for client-side routing.\nWhy?: UI Router offers all the features of the Angular router plus a few additional ones including nested routes and states.\nWhy?: The syntax is quite similar to the Angular router and is easy to migrate to UI Router.\n Note: You can use a provider such as the routerHelperProvider shown below to help configure states across files, during the run phase.\n// customers.routes.js angular .module('app.customers') .run(appRun); /* @ngInject */ function appRun(routerHelper) { routerHelper.configureStates(getStates()); } function getStates() { return [ { state: 'customer', config: { abstract: true, template: '\u0026lt;ui-view class=\u0026quot;shuffle-animation\u0026quot;/\u0026gt;', url: '/customer' } } ]; }  // routerHelperProvider.js angular .module('blocks.router') .provider('routerHelper', routerHelperProvider); routerHelperProvider.$inject = ['$locationProvider', '$stateProvider', '$urlRouterProvider']; /* @ngInject */ function routerHelperProvider($locationProvider, $stateProvider, $urlRouterProvider) { /* jshint validthis:true */ this.$get = RouterHelper; $locationProvider.html5Mode(true); RouterHelper.$inject = ['$state']; /* @ngInject */ function RouterHelper($state) { var hasOtherwise = false; var service = { configureStates: configureStates, getStates: getStates }; return service; /////////////// function configureStates(states, otherwisePath) { states.forEach(function(state) { $stateProvider.state(state.state, state.config); }); if (otherwisePath \u0026amp;\u0026amp; !hasOtherwise) { hasOtherwise = true; $urlRouterProvider.otherwise(otherwisePath); } } function getStates() { return $state.get(); } } }   [Style Y271]  Define routes for views in the module where they exist. Each module should contain the routes for the views in the module.\nWhy?: Each module should be able to stand on its own.\nWhy?: When removing a module or adding a module, the app will only contain routes that point to existing views.\nWhy?: This makes it easy to enable or disable portions of an application without concern over orphaned routes.\n  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/task-automation/",
	"title": "Task Automation",
	"tags": [],
	"description": "",
	"content": " Task Automation Use Gulp or Grunt for creating automated tasks. Gulp leans to code over configuration while Grunt leans to configuration over code. I personally prefer Gulp as I feel it is easier to read and write, but both are excellent.\n Learn more about gulp and patterns for task automation in my Gulp Pluralsight course\n [Style Y400]  Use task automation to list module definition files *.module.js before all other application JavaScript files.\nWhy?: Angular needs the module definitions to be registered before they are used.\nWhy?: Naming modules with a specific pattern such as *.module.js makes it easy to grab them with a glob and list them first.\nvar clientApp = './src/client/app/'; // Always grab module files first var files = [ clientApp + '**/*.module.js', clientApp + '**/*.js' ];   Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/filters/",
	"title": "Filters",
	"tags": [],
	"description": "",
	"content": " Filters [Style Y420]  Avoid using filters for scanning all properties of a complex object graph. Use filters for select properties.\nWhy?: Filters can easily be abused and negatively affect performance if not used wisely, for example when a filter hits a large and deep object graph.\n  Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/angular1/angular-docs/",
	"title": "Angular Docs",
	"tags": [],
	"description": "",
	"content": " Angular docs For anything else, API reference, check the Angular documentation.\nBack to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/",
	"title": "JavaScript Style Guide",
	"tags": [],
	"description": "",
	"content": " Diff Style Guides:  ES5 ES6  Others  Testing Performance Resources In the Wild The JavaScript Style Guide Guide  "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/",
	"title": "ES5",
	"tags": [],
	"description": "",
	"content": " Airbnb JavaScript Style Guide(ES5) { A mostly reasonable approach to JavaScript\nTable of Contents  Types Objects Arrays Strings Functions Properties Variables Hoisting Comparison Operators \u0026amp; Equality Blocks Comments Whitespace Commas Semicolons Type Casting \u0026amp; Coercion Naming Conventions Accessors Constructors Events Modules jQuery ECMAScript 5 Compatibility  "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/types/",
	"title": "Types",
	"tags": [],
	"description": "",
	"content": " Types  Primitives: When you access a primitive type you work directly on its value.\n string number boolean null undefined  var foo = 1; var bar = foo; bar = 9; console.log(foo, bar); // =\u0026gt; 1, 9  Complex: When you access a complex type you work on a reference to its value.\n object array function  var foo = [1, 2]; var bar = foo; bar[0] = 9; console.log(foo[0], bar[0]); // =\u0026gt; 9, 9   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/objects/",
	"title": "Objects",
	"tags": [],
	"description": "",
	"content": " Objects  Use the literal syntax for object creation.\n// bad var item = new Object(); // good var item = {};  Don\u0026rsquo;t use reserved words as keys. It won\u0026rsquo;t work in IE8. More info.\n// bad var superman = { default: { clark: 'kent' }, private: true }; // good var superman = { defaults: { clark: 'kent' }, hidden: true };  Use readable synonyms in place of reserved words.\n// bad var superman = { class: 'alien' }; // bad var superman = { klass: 'alien' }; // good var superman = { type: 'alien' };   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/arrays/",
	"title": "Arrays",
	"tags": [],
	"description": "",
	"content": " Arrays  Use the literal syntax for array creation.\n// bad var items = new Array(); // good var items = [];  Use Array#push instead of direct assignment to add items to an array.\nvar someStack = []; // bad someStack[someStack.length] = 'abracadabra'; // good someStack.push('abracadabra');  When you need to copy an array use Array#slice. jsPerf\nvar len = items.length; var itemsCopy = []; var i; // bad for (i = 0; i \u0026lt; len; i++) { itemsCopy[i] = items[i]; } // good itemsCopy = items.slice();  To convert an array-like object to an array, use Array#slice.\nfunction trigger() { var args = Array.prototype.slice.call(arguments); ... }   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/strings/",
	"title": "Strings",
	"tags": [],
	"description": "",
	"content": " Strings  Use single quotes '' for strings.\n// bad var name = \u0026quot;Bob Parr\u0026quot;; // good var name = 'Bob Parr'; // bad var fullName = \u0026quot;Bob \u0026quot; + this.lastName; // good var fullName = 'Bob ' + this.lastName;  Strings longer than 100 characters should be written across multiple lines using string concatenation.\n Note: If overused, long strings with concatenation could impact performance. jsPerf \u0026amp; Discussion.\n// bad var errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'; // bad var errorMessage = 'This is a super long error that was thrown because \\ of Batman. When you stop to think about how Batman had anything to do \\ with this, you would get nowhere \\ fast.'; // good var errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.';  When programmatically building up a string, use Array#join instead of string concatenation. Mostly for IE: jsPerf.\nvar items; var messages; var length; var i; messages = [{ state: 'success', message: 'This one worked.' }, { state: 'success', message: 'This one worked as well.' }, { state: 'error', message: 'This one did not work.' }]; length = messages.length; // bad function inbox(messages) { items = '\u0026lt;ul\u0026gt;'; for (i = 0; i \u0026lt; length; i++) { items += '\u0026lt;li\u0026gt;' + messages[i].message + '\u0026lt;/li\u0026gt;'; } return items + '\u0026lt;/ul\u0026gt;'; } // good function inbox(messages) { items = []; for (i = 0; i \u0026lt; length; i++) { // use direct assignment in this case because we're micro-optimizing. items[i] = '\u0026lt;li\u0026gt;' + messages[i].message + '\u0026lt;/li\u0026gt;'; } return '\u0026lt;ul\u0026gt;' + items.join('') + '\u0026lt;/ul\u0026gt;'; }   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/functions/",
	"title": "Functions",
	"tags": [],
	"description": "",
	"content": " Functions  Function expressions:\n// anonymous function expression var anonymous = function () { return true; }; // named function expression var named = function named() { return true; }; // immediately-invoked function expression (IIFE) (function () { console.log('Welcome to the Internet. Please follow me.'); }());  Never declare a function in a non-function block (if, while, etc). Assign the function to a variable instead. Browsers will allow you to do it, but they all interpret it differently, which is bad news bears.\n Note: ECMA-262 defines a block as a list of statements. A function declaration is not a statement. Read ECMA-262\u0026rsquo;s note on this issue.\n// bad if (currentUser) { function test() { console.log('Nope.'); } } // good var test; if (currentUser) { test = function test() { console.log('Yup.'); }; }  Never name a parameter arguments. This will take precedence over the arguments object that is given to every function scope.\n// bad function nope(name, options, arguments) { // ...stuff... } // good function yup(name, options, args) { // ...stuff... }   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/properties/",
	"title": "Properties",
	"tags": [],
	"description": "",
	"content": " Properties  Use dot notation when accessing properties.\nvar luke = { jedi: true, age: 28 }; // bad var isJedi = luke['jedi']; // good var isJedi = luke.jedi;  Use subscript notation [] when accessing properties with a variable.\nvar luke = { jedi: true, age: 28 }; function getProp(prop) { return luke[prop]; } var isJedi = getProp('jedi');   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/variables/",
	"title": "Variables",
	"tags": [],
	"description": "",
	"content": " Variables  Always use var to declare variables. Not doing so will result in global variables. We want to avoid polluting the global namespace. Captain Planet warned us of that.\n// bad superPower = new SuperPower(); // good var superPower = new SuperPower();  Use one var declaration per variable. It\u0026rsquo;s easier to add new variable declarations this way, and you never have to worry about swapping out a ; for a , or introducing punctuation-only diffs.\n// bad var items = getItems(), goSportsTeam = true, dragonball = 'z'; // bad // (compare to above, and try to spot the mistake) var items = getItems(), goSportsTeam = true; dragonball = 'z'; // good var items = getItems(); var goSportsTeam = true; var dragonball = 'z';  Declare unassigned variables last. This is helpful when later on you might need to assign a variable depending on one of the previous assigned variables.\n// bad var i, len, dragonball, items = getItems(), goSportsTeam = true; // bad var i; var items = getItems(); var dragonball; var goSportsTeam = true; var len; // good var items = getItems(); var goSportsTeam = true; var dragonball; var length; var i;  Assign variables at the top of their scope. This helps avoid issues with variable declaration and assignment hoisting related issues.\n// bad function () { test(); console.log('doing stuff..'); //..other stuff.. var name = getName(); if (name === 'test') { return false; } return name; } // good function () { var name = getName(); test(); console.log('doing stuff..'); //..other stuff.. if (name === 'test') { return false; } return name; } // bad - unnecessary function call function () { var name = getName(); if (!arguments.length) { return false; } this.setFirstName(name); return true; } // good function () { var name; if (!arguments.length) { return false; } name = getName(); this.setFirstName(name); return true; }   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/hoisting/",
	"title": "Hoisting",
	"tags": [],
	"description": "",
	"content": " Hoisting  Variable declarations get hoisted to the top of their scope, but their assignment does not.\n// we know this wouldn't work (assuming there // is no notDefined global variable) function example() { console.log(notDefined); // =\u0026gt; throws a ReferenceError } // creating a variable declaration after you // reference the variable will work due to // variable hoisting. Note: the assignment // value of `true` is not hoisted. function example() { console.log(declaredButNotAssigned); // =\u0026gt; undefined var declaredButNotAssigned = true; } // The interpreter is hoisting the variable // declaration to the top of the scope, // which means our example could be rewritten as: function example() { var declaredButNotAssigned; console.log(declaredButNotAssigned); // =\u0026gt; undefined declaredButNotAssigned = true; }  Anonymous function expressions hoist their variable name, but not the function assignment.\nfunction example() { console.log(anonymous); // =\u0026gt; undefined anonymous(); // =\u0026gt; TypeError anonymous is not a function var anonymous = function () { console.log('anonymous function expression'); }; }  Named function expressions hoist the variable name, not the function name or the function body.\nfunction example() { console.log(named); // =\u0026gt; undefined named(); // =\u0026gt; TypeError named is not a function superPower(); // =\u0026gt; ReferenceError superPower is not defined var named = function superPower() { console.log('Flying'); }; } // the same is true when the function name // is the same as the variable name. function example() { console.log(named); // =\u0026gt; undefined named(); // =\u0026gt; TypeError named is not a function var named = function named() { console.log('named'); } }  Function declarations hoist their name and the function body.\nfunction example() { superPower(); // =\u0026gt; Flying function superPower() { console.log('Flying'); } }  For more information refer to JavaScript Scoping \u0026amp; Hoisting by Ben Cherry.\n  ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/comparison-operators--equality/",
	"title": "Comparison Operators &amp; Equality",
	"tags": [],
	"description": "",
	"content": " Comparison Operators \u0026amp; Equality  Use === and !== over == and !=. Conditional statements such as the if statement evaluate their expression using coercion with the ToBoolean abstract method and always follow these simple rules:\n Objects evaluate to true Undefined evaluates to false Null evaluates to false Booleans evaluate to the value of the boolean Numbers evaluate to false if +0, -0, or NaN, otherwise true Strings evaluate to false if an empty string '', otherwise true  if ([0]) { // true // An array is an object, objects evaluate to true }  Use shortcuts.\n// bad if (name !== '') { // ...stuff... } // good if (name) { // ...stuff... } // bad if (collection.length \u0026gt; 0) { // ...stuff... } // good if (collection.length) { // ...stuff... }  For more information see Truth Equality and JavaScript by Angus Croll.\n  ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/blocks/",
	"title": "Blocks",
	"tags": [],
	"description": "",
	"content": " Blocks  Use braces with all multi-line blocks.\n// bad if (test) return false; // good if (test) return false; // good if (test) { return false; } // bad function () { return false; } // good function () { return false; }  If you\u0026rsquo;re using multi-line blocks with if and else, put else on the same line as your if block\u0026rsquo;s closing brace.\n// bad if (test) { thing1(); thing2(); } else { thing3(); } // good if (test) { thing1(); thing2(); } else { thing3(); }   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/comments/",
	"title": "Comments",
	"tags": [],
	"description": "",
	"content": " Comments  Use /** ... */ for multi-line comments. Include a description, specify types and values for all parameters and return values.\n```javascript // bad // make() returns a new element // based on the passed in tag name // // @param {String} tag // @return {Element} element function make(tag) {\n// \u0026hellip;stuff\u0026hellip;\nreturn element; }\n// good /**\n make() returns a new element based on the passed in tag name * @param {String} tag @return {Element} element */ function make(tag) {  // \u0026hellip;stuff\u0026hellip;\nreturn element; } ```\n Use // for single line comments. Place single line comments on a newline above the subject of the comment. Put an empty line before the comment.\n// bad var active = true; // is current tab // good // is current tab var active = true; // bad function getType() { console.log('fetching type...'); // set the default type to 'no type' var type = this.type || 'no type'; return type; } // good function getType() { console.log('fetching type...'); // set the default type to 'no type' var type = this.type || 'no type'; return type; }  Prefixing your comments with FIXME or TODO helps other developers quickly understand if you\u0026rsquo;re pointing out a problem that needs to be revisited, or if you\u0026rsquo;re suggesting a solution to the problem that needs to be implemented. These are different than regular comments because they are actionable. The actions are FIXME -- need to figure this out or TODO -- need to implement.\n Use // FIXME: to annotate problems.\nfunction Calculator() { // FIXME: shouldn't use a global here total = 0; return this; }  Use // TODO: to annotate solutions to problems.\nfunction Calculator() { // TODO: total should be configurable by an options param this.total = 0; return this; }   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/whitespace/",
	"title": "Whitespace",
	"tags": [],
	"description": "",
	"content": " Whitespace  Use soft tabs set to 2 spaces.\n// bad function () { ∙∙∙∙var name; } // bad function () { ∙var name; } // good function () { ∙∙var name; }  Place 1 space before the leading brace.\n// bad function test(){ console.log('test'); } // good function test() { console.log('test'); } // bad dog.set('attr',{ age: '1 year', breed: 'Bernese Mountain Dog' }); // good dog.set('attr', { age: '1 year', breed: 'Bernese Mountain Dog' });  Place 1 space before the opening parenthesis in control statements (if, while etc.). Place no space before the argument list in function calls and declarations.\n// bad if(isJedi) { fight (); } // good if (isJedi) { fight(); } // bad function fight () { console.log ('Swooosh!'); } // good function fight() { console.log('Swooosh!'); }  Set off operators with spaces.\n// bad var x=y+5; // good var x = y + 5;  End files with a single newline character.\n// bad (function (global) { // ...stuff... })(this);  // bad (function (global) { // ...stuff... })(this);↵ ↵  // good (function (global) { // ...stuff... })(this);↵  Use indentation when making long method chains. Use a leading dot, which emphasizes that the line is a method call, not a new statement.\n// bad $('#items').find('.selected').highlight().end().find('.open').updateCount(); // bad $('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount(); // good $('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount(); // bad var leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led); // good var leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led);  Leave a blank line after blocks and before the next statement\n// bad if (foo) { return bar; } return baz; // good if (foo) { return bar; } return baz; // bad var obj = { foo: function () { }, bar: function () { } }; return obj; // good var obj = { foo: function () { }, bar: function () { } }; return obj;   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/commas/",
	"title": "Commas",
	"tags": [],
	"description": "",
	"content": " Commas  Leading commas: Nope.\n// bad var story = [ once , upon , aTime ]; // good var story = [ once, upon, aTime ]; // bad var hero = { firstName: 'Bob' , lastName: 'Parr' , heroName: 'Mr. Incredible' , superPower: 'strength' }; // good var hero = { firstName: 'Bob', lastName: 'Parr', heroName: 'Mr. Incredible', superPower: 'strength' };  Additional trailing comma: Nope. This can cause problems with IE6/7 and IE9 if it\u0026rsquo;s in quirksmode. Also, in some implementations of ES3 would add length to an array if it had an additional trailing comma. This was clarified in ES5 (source):\n   Edition 5 clarifies the fact that a trailing comma at the end of an ArrayInitialiser does not add to the length of the array. This is not a semantic change from Edition 3 but some implementations may have previously misinterpreted this.\n ```javascript // bad var hero = { firstName: 'Kevin', lastName: 'Flynn', }; var heroes = [ 'Batman', 'Superman', ]; // good var hero = { firstName: 'Kevin', lastName: 'Flynn' }; var heroes = [ 'Batman', 'Superman' ]; ```  ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/semicolons/",
	"title": "Semicolons",
	"tags": [],
	"description": "",
	"content": " Semicolons  Yup.\n// bad (function () { var name = 'Skywalker' return name })() // good (function () { var name = 'Skywalker'; return name; })(); // good (guards against the function becoming an argument when two files with IIFEs are concatenated) ;(function () { var name = 'Skywalker'; return name; })();  Read more.\n  ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/type-casting--coercion/",
	"title": "Type Casting &amp; Coercion",
	"tags": [],
	"description": "",
	"content": " Type Casting \u0026amp; Coercion  Perform type coercion at the beginning of the statement. Strings:\n// =\u0026gt; this.reviewScore = 9; // bad var totalScore = this.reviewScore + ''; // good var totalScore = '' + this.reviewScore; // bad var totalScore = '' + this.reviewScore + ' total score'; // good var totalScore = this.reviewScore + ' total score';  Use parseInt for Numbers and always with a radix for type casting.\nvar inputValue = '4'; // bad var val = new Number(inputValue); // bad var val = +inputValue; // bad var val = inputValue \u0026gt;\u0026gt; 0; // bad var val = parseInt(inputValue); // good var val = Number(inputValue); // good var val = parseInt(inputValue, 10);  If for whatever reason you are doing something wild and parseInt is your bottleneck and need to use Bitshift for performance reasons, leave a comment explaining why and what you\u0026rsquo;re doing.\n```javascript // good /**\n parseInt was the reason my code was slow. Bitshifting the String to coerce it to a Number made it a lot faster. */ var val = inputValue \u0026gt;\u0026gt; 0; ```  Note: Be careful when using bitshift operations. Numbers are represented as 64-bit values, but Bitshift operations always return a 32-bit integer (source). Bitshift can lead to unexpected behavior for integer values larger than 32 bits. Discussion. Largest signed 32-bit Int is 2,147,483,647:\n2147483647 \u0026gt;\u0026gt; 0 //=\u0026gt; 2147483647 2147483648 \u0026gt;\u0026gt; 0 //=\u0026gt; -2147483648 2147483649 \u0026gt;\u0026gt; 0 //=\u0026gt; -2147483647  Booleans:\nvar age = 0; // bad var hasAge = new Boolean(age); // good var hasAge = Boolean(age); // good var hasAge = !!age;   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/naming-conventions/",
	"title": "Naming Conventions",
	"tags": [],
	"description": "",
	"content": " Naming Conventions  Avoid single letter names. Be descriptive with your naming.\n// bad function q() { // ...stuff... } // good function query() { // ..stuff.. }  Use camelCase when naming objects, functions, and instances.\n// bad var OBJEcttsssss = {}; var this_is_my_object = {}; var o = {}; function c() {} // good var thisIsMyObject = {}; function thisIsMyFunction() {}  Use PascalCase when naming constructors or classes.\n// bad function user(options) { this.name = options.name; } var bad = new user({ name: 'nope' }); // good function User(options) { this.name = options.name; } var good = new User({ name: 'yup' });  Do not use trailing or leading underscores.\n Why? JavaScript does not have the concept of privacy in terms of properties or methods. Although a leading underscore is a common convention to mean “private”, in fact, these properties are fully public, and as such, are part of your public API contract. This convention might lead developers to wrongly think that a change won\u0026rsquo;t count as breaking, or that tests aren\u0026rsquo;t needed. tl;dr: if you want something to be “private”, it must not be observably present.\n // bad this.__firstName__ = 'Panda'; this.firstName_ = 'Panda'; this._firstName = 'Panda'; // good this.firstName = 'Panda';  Don\u0026rsquo;t save references to this. Use Function#bind.\n// bad function () { var self = this; return function () { console.log(self); }; } // bad function () { var that = this; return function () { console.log(that); }; } // bad function () { var _this = this; return function () { console.log(_this); }; } // good function () { return function () { console.log(this); }.bind(this); }  Name your functions. This is helpful for stack traces.\n// bad var log = function (msg) { console.log(msg); }; // good var log = function log(msg) { console.log(msg); };  Note: IE8 and below exhibit some quirks with named function expressions. See http://kangax.github.io/nfe/ for more info.\n If your file exports a single class, your filename should be exactly the name of the class.\n// file contents class CheckBox { // ... } module.exports = CheckBox; // in some other file // bad var CheckBox = require('./checkBox'); // bad var CheckBox = require('./check_box'); // good var CheckBox = require('./CheckBox');   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/accessors/",
	"title": "Accessors",
	"tags": [],
	"description": "",
	"content": " Accessors  Accessor functions for properties are not required. If you do make accessor functions use getVal() and setVal(\u0026lsquo;hello\u0026rsquo;).\n// bad dragon.age(); // good dragon.getAge(); // bad dragon.age(25); // good dragon.setAge(25);  If the property is a boolean, use isVal() or hasVal().\n// bad if (!dragon.age()) { return false; } // good if (!dragon.hasAge()) { return false; }  It\u0026rsquo;s okay to create get() and set() functions, but be consistent.\nfunction Jedi(options) { options || (options = {}); var lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber); } Jedi.prototype.set = function set(key, val) { this[key] = val; }; Jedi.prototype.get = function get(key) { return this[key]; };   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/constructors/",
	"title": "Constructors",
	"tags": [],
	"description": "",
	"content": " Constructors  Assign methods to the prototype object, instead of overwriting the prototype with a new object. Overwriting the prototype makes inheritance impossible: by resetting the prototype you\u0026rsquo;ll overwrite the base!\nfunction Jedi() { console.log('new jedi'); } // bad Jedi.prototype = { fight: function fight() { console.log('fighting'); }, block: function block() { console.log('blocking'); } }; // good Jedi.prototype.fight = function fight() { console.log('fighting'); }; Jedi.prototype.block = function block() { console.log('blocking'); };  Methods can return this to help with method chaining.\n// bad Jedi.prototype.jump = function jump() { this.jumping = true; return true; }; Jedi.prototype.setHeight = function setHeight(height) { this.height = height; }; var luke = new Jedi(); luke.jump(); // =\u0026gt; true luke.setHeight(20); // =\u0026gt; undefined // good Jedi.prototype.jump = function jump() { this.jumping = true; return this; }; Jedi.prototype.setHeight = function setHeight(height) { this.height = height; return this; }; var luke = new Jedi(); luke.jump() .setHeight(20);  It\u0026rsquo;s okay to write a custom toString() method, just make sure it works successfully and causes no side effects.\nfunction Jedi(options) { options || (options = {}); this.name = options.name || 'no name'; } Jedi.prototype.getName = function getName() { return this.name; }; Jedi.prototype.toString = function toString() { return 'Jedi - ' + this.getName(); };   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/events/",
	"title": "Events",
	"tags": [],
	"description": "",
	"content": " Events  When attaching data payloads to events (whether DOM events or something more proprietary like Backbone events), pass a hash instead of a raw value. This allows a subsequent contributor to add more data to the event payload without finding and updating every handler for the event. For example, instead of:\n// bad $(this).trigger('listingUpdated', listing.id); ... $(this).on('listingUpdated', function (e, listingId) { // do something with listingId });  prefer:\n// good $(this).trigger('listingUpdated', { listingId : listing.id }); ... $(this).on('listingUpdated', function (e, data) { // do something with data.listingId });   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/modules/",
	"title": "Modules",
	"tags": [],
	"description": "",
	"content": " Modules  The module should start with a !. This ensures that if a malformed module forgets to include a final semicolon there aren\u0026rsquo;t errors in production when the scripts get concatenated. Explanation The file should be named with camelCase, live in a folder with the same name, and match the name of the single export. Add a method called noConflict() that sets the exported module to the previous version and returns this one. Always declare 'use strict'; at the top of the module.\n// fancyInput/fancyInput.js !function (global) { 'use strict'; var previousFancyInput = global.FancyInput; function FancyInput(options) { this.options = options || {}; } FancyInput.noConflict = function noConflict() { global.FancyInput = previousFancyInput; return FancyInput; }; global.FancyInput = FancyInput; }(this);   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/jquery/",
	"title": "Jquery",
	"tags": [],
	"description": "",
	"content": " jQuery  Prefix jQuery object variables with a $.\n// bad var sidebar = $('.sidebar'); // good var $sidebar = $('.sidebar');  Cache jQuery lookups.\n// bad function setSidebar() { $('.sidebar').hide(); // ...stuff... $('.sidebar').css({ 'background-color': 'pink' }); } // good function setSidebar() { var $sidebar = $('.sidebar'); $sidebar.hide(); // ...stuff... $sidebar.css({ 'background-color': 'pink' }); }  For DOM queries use Cascading $('.sidebar ul') or parent \u0026gt; child $('.sidebar \u0026gt; ul'). jsPerf\n Use find with scoped jQuery object queries.\n// bad $('ul', '.sidebar').hide(); // bad $('.sidebar').find('ul').hide(); // good $('.sidebar ul').hide(); // good $('.sidebar \u0026gt; ul').hide(); // good $sidebar.find('ul').hide();   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es5/ecmascript-5-compatibility/",
	"title": "Ecmascript 5 Compatibility",
	"tags": [],
	"description": "",
	"content": " ECMAScript 5 Compatibility  Refer to Kangax\u0026rsquo;s ES5 compatibility table.  ⬆ Back to Table of Contents\n}; "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/",
	"title": "ES6",
	"tags": [],
	"description": "",
	"content": " Airbnb JavaScript Style Guide(ES6+) { A mostly reasonable approach to JavaScript\nTable of Contents  Types References Objects Arrays Destructuring Strings Functions Arrow Functions Classes \u0026amp; Constructors Modules Iterators and Generators Properties Variables Hoisting Comparison Operators \u0026amp; Equality Blocks Control Statements Comments Whitespace Commas Semicolons Type Casting \u0026amp; Coercion Naming Conventions Accessors Events jQuery ECMAScript 6+ (ES 2015+) Styles  "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/types/",
	"title": "Types",
	"tags": [],
	"description": "",
	"content": " Types  1.1 Primitives: When you access a primitive type you work directly on its value.\n string number boolean null undefined  const foo = 1; let bar = foo; bar = 9; console.log(foo, bar); // =\u0026gt; 1, 9  1.2 Complex: When you access a complex type you work on a reference to its value.\n object array function  const foo = [1, 2]; const bar = foo; bar[0] = 9; console.log(foo[0], bar[0]); // =\u0026gt; 9, 9   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/references/",
	"title": "References",
	"tags": [],
	"description": "",
	"content": " References  2.1 Use const for all of your references; avoid using var. eslint: prefer-const, no-const-assign\n Why? This ensures that you can’t reassign your references, which can lead to bugs and difficult to comprehend code.\n // bad var a = 1; var b = 2; // good const a = 1; const b = 2;  2.2 If you must reassign references, use let instead of var. eslint: no-var jscs: disallowVar\n Why? let is block-scoped rather than function-scoped like var.\n // bad var count = 1; if (true) { count += 1; } // good, use the let. let count = 1; if (true) { count += 1; }  2.3 Note that both let and const are block-scoped.\n// const and let only exist in the blocks they are defined in. { let a = 1; const b = 1; } console.log(a); // ReferenceError console.log(b); // ReferenceError   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/objects/",
	"title": "Objects",
	"tags": [],
	"description": "",
	"content": " Objects  3.1 Use the literal syntax for object creation. eslint: no-new-object\n// bad const item = new Object(); // good const item = {};  3.2 Use computed property names when creating objects with dynamic property names.\n Why? They allow you to define all the properties of an object in one place.\n function getKey(k) { return `a key named ${k}`; } // bad const obj = { id: 5, name: 'San Francisco', }; obj[getKey('enabled')] = true; // good const obj = { id: 5, name: 'San Francisco', [getKey('enabled')]: true, };  3.3 Use object method shorthand. eslint: object-shorthand jscs: requireEnhancedObjectLiterals\n// bad const atom = { value: 1, addValue: function (value) { return atom.value + value; }, }; // good const atom = { value: 1, addValue(value) { return atom.value + value; }, };  3.4 Use property value shorthand. eslint: object-shorthand jscs: requireEnhancedObjectLiterals\n Why? It is shorter to write and descriptive.\n const lukeSkywalker = 'Luke Skywalker'; // bad const obj = { lukeSkywalker: lukeSkywalker, }; // good const obj = { lukeSkywalker, };  3.5 Group your shorthand properties at the beginning of your object declaration.\n Why? It’s easier to tell which properties are using the shorthand.\n const anakinSkywalker = 'Anakin Skywalker'; const lukeSkywalker = 'Luke Skywalker'; // bad const obj = { episodeOne: 1, twoJediWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker, }; // good const obj = { lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJediWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4, };  3.6 Only quote properties that are invalid identifiers. eslint: quote-props jscs: disallowQuotedKeysInObjects\n Why? In general we consider it subjectively easier to read. It improves syntax highlighting, and is also more easily optimized by many JS engines.\n // bad const bad = { 'foo': 3, 'bar': 4, 'data-blah': 5, }; // good const good = { foo: 3, bar: 4, 'data-blah': 5, };  3.7 Do not call Object.prototype methods directly, such as hasOwnProperty, propertyIsEnumerable, and isPrototypeOf.\n Why? These methods may be shadowed by properties on the object in question - consider { hasOwnProperty: false } - or, the object may be a null object (Object.create(null)).\n // bad console.log(object.hasOwnProperty(key)); // good console.log(Object.prototype.hasOwnProperty.call(object, key)); // best const has = Object.prototype.hasOwnProperty; // cache the lookup once, in module scope. /* or */ import has from 'has'; // ... console.log(has.call(object, key));  3.8 Prefer the object spread operator over Object.assign to shallow-copy objects. Use the object rest operator to get a new object with certain properties omitted.\n// very bad const original = { a: 1, b: 2 }; const copy = Object.assign(original, { c: 3 }); // this mutates `original` ಠ_ಠ delete copy.a; // so does this // bad const original = { a: 1, b: 2 }; const copy = Object.assign({}, original, { c: 3 }); // copy =\u0026gt; { a: 1, b: 2, c: 3 } // good const original = { a: 1, b: 2 }; const copy = { ...original, c: 3 }; // copy =\u0026gt; { a: 1, b: 2, c: 3 } const { a, ...noA } = copy; // noA =\u0026gt; { b: 2, c: 3 }   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/arrays/",
	"title": "Arrays",
	"tags": [],
	"description": "",
	"content": " Arrays  4.1 Use the literal syntax for array creation. eslint: no-array-constructor\n// bad const items = new Array(); // good const items = [];  4.2 Use Array#push instead of direct assignment to add items to an array.\nconst someStack = []; // bad someStack[someStack.length] = 'abracadabra'; // good someStack.push('abracadabra');  4.3 Use array spreads ... to copy arrays.\n// bad const len = items.length; const itemsCopy = []; let i; for (i = 0; i \u0026lt; len; i += 1) { itemsCopy[i] = items[i]; } // good const itemsCopy = [...items];  4.4 To convert an array-like object to an array, use Array.from.\nconst foo = document.querySelectorAll('.foo'); const nodes = Array.from(foo);  4.5 Use return statements in array method callbacks. It’s ok to omit the return if the function body consists of a single statement returning an expression without side effects, following 8.2. eslint: array-callback-return\n// good [1, 2, 3].map((x) =\u0026gt; { const y = x + 1; return x * y; }); // good [1, 2, 3].map(x =\u0026gt; x + 1); // bad const flat = {}; [[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =\u0026gt; { const flatten = memo.concat(item); flat[index] = flatten; }); // good const flat = {}; [[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) =\u0026gt; { const flatten = memo.concat(item); flat[index] = flatten; return flatten; }); // bad inbox.filter((msg) =\u0026gt; { const { subject, author } = msg; if (subject === 'Mockingbird') { return author === 'Harper Lee'; } else { return false; } }); // good inbox.filter((msg) =\u0026gt; { const { subject, author } = msg; if (subject === 'Mockingbird') { return author === 'Harper Lee'; } return false; });  4.6 Use line breaks after open and before close array brackets if an array has multiple lines\n// bad const arr = [ [0, 1], [2, 3], [4, 5], ]; const objectInArray = [{ id: 1, }, { id: 2, }]; const numberInArray = [ 1, 2, ]; // good const arr = [[0, 1], [2, 3], [4, 5]]; const objectInArray = [ { id: 1, }, { id: 2, }, ]; const numberInArray = [ 1, 2, ];   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/destructuring/",
	"title": "Destructuring",
	"tags": [],
	"description": "",
	"content": " Destructuring  5.1 Use object destructuring when accessing and using multiple properties of an object. jscs: requireObjectDestructuring\n Why? Destructuring saves you from creating temporary references for those properties.\n // bad function getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; return `${firstName} ${lastName}`; } // good function getFullName(user) { const { firstName, lastName } = user; return `${firstName} ${lastName}`; } // best function getFullName({ firstName, lastName }) { return `${firstName} ${lastName}`; }  5.2 Use array destructuring. jscs: requireArrayDestructuring\nconst arr = [1, 2, 3, 4]; // bad const first = arr[0]; const second = arr[1]; // good const [first, second] = arr;  5.3 Use object destructuring for multiple return values, not array destructuring. jscs: disallowArrayDestructuringReturn\n Why? You can add new properties over time or change the order of things without breaking call sites.\n // bad function processInput(input) { // then a miracle occurs return [left, right, top, bottom]; } // the caller needs to think about the order of return data const [left, __, top] = processInput(input); // good function processInput(input) { // then a miracle occurs return { left, right, top, bottom }; } // the caller selects only the data they need const { left, top } = processInput(input);   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/strings/",
	"title": "Strings",
	"tags": [],
	"description": "",
	"content": " Strings  6.1 Use single quotes '' for strings. eslint: quotes jscs: validateQuoteMarks\n// bad const name = \u0026quot;Capt. Janeway\u0026quot;; // bad - template literals should contain interpolation or newlines const name = `Capt. Janeway`; // good const name = 'Capt. Janeway';  6.2 Strings that cause the line to go over 100 characters should not be written across multiple lines using string concatenation.\n Why? Broken strings are painful to work with and make code less searchable.\n // bad const errorMessage = 'This is a super long error that was thrown because \\ of Batman. When you stop to think about how Batman had anything to do \\ with this, you would get nowhere \\ fast.'; // bad const errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.'; // good const errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';  6.3 When programmatically building up strings, use template strings instead of concatenation. eslint: prefer-template template-curly-spacing jscs: requireTemplateStrings\n Why? Template strings give you a readable, concise syntax with proper newlines and string interpolation features.\n // bad function sayHi(name) { return 'How are you, ' + name + '?'; } // bad function sayHi(name) { return ['How are you, ', name, '?'].join(); } // bad function sayHi(name) { return `How are you, ${ name }?`; } // good function sayHi(name) { return `How are you, ${name}?`; }  6.4 Never use eval() on a string, it opens too many vulnerabilities. eslint: no-eval\n 6.5 Do not unnecessarily escape characters in strings. eslint: no-useless-escape\n Why? Backslashes harm readability, thus they should only be present when necessary.\n // bad const foo = '\\'this\\' \\i\\s \\\u0026quot;quoted\\\u0026quot;'; // good const foo = '\\'this\\' is \u0026quot;quoted\u0026quot;'; const foo = `my name is '${name}'`;   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/functions/",
	"title": "Functions",
	"tags": [],
	"description": "",
	"content": " Functions  7.1 Use named function expressions instead of function declarations. eslint: func-style jscs: disallowFunctionDeclarations\n Why? Function declarations are hoisted, which means that it’s easy - too easy - to reference the function before it is defined in the file. This harms readability and maintainability. If you find that a function’s definition is large or complex enough that it is interfering with understanding the rest of the file, then perhaps it’s time to extract it to its own module! Don’t forget to name the expression - anonymous functions can make it harder to locate the problem in an Error’s call stack. (Discussion)\n // bad function foo() { // ... } // bad const foo = function () { // ... }; // good const foo = function bar() { // ... };  7.2 Wrap immediately invoked function expressions in parentheses. eslint: wrap-iife jscs: requireParenthesesAroundIIFE\n Why? An immediately invoked function expression is a single unit - wrapping both it, and its invocation parens, in parens, cleanly expresses this. Note that in a world with modules everywhere, you almost never need an IIFE.\n // immediately-invoked function expression (IIFE) (function () { console.log('Welcome to the Internet. Please follow me.'); }());  7.3 Never declare a function in a non-function block (if, while, etc). Assign the function to a variable instead. Browsers will allow you to do it, but they all interpret it differently, which is bad news bears. eslint: no-loop-func\n 7.4 Note: ECMA-262 defines a block as a list of statements. A function declaration is not a statement. Read ECMA-262’s note on this issue.\n// bad if (currentUser) { function test() { console.log('Nope.'); } } // good let test; if (currentUser) { test = () =\u0026gt; { console.log('Yup.'); }; }  7.5 Never name a parameter arguments. This will take precedence over the arguments object that is given to every function scope.\n// bad function foo(name, options, arguments) { // ... } // good function foo(name, options, args) { // ... }  7.6 Never use arguments, opt to use rest syntax ... instead. eslint: prefer-rest-params\n Why? ... is explicit about which arguments you want pulled. Plus, rest arguments are a real Array, and not merely Array-like like arguments.\n // bad function concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join(''); } // good function concatenateAll(...args) { return args.join(''); }  7.7 Use default parameter syntax rather than mutating function arguments.\n// really bad function handleThings(opts) { // No! We shouldn’t mutate function arguments. // Double bad: if opts is falsy it'll be set to an object which may // be what you want but it can introduce subtle bugs. opts = opts || {}; // ... } // still bad function handleThings(opts) { if (opts === void 0) { opts = {}; } // ... } // good function handleThings(opts = {}) { // ... }  7.8 Avoid side effects with default parameters.\n Why? They are confusing to reason about.\n var b = 1; // bad function count(a = b++) { console.log(a); } count(); // 1 count(); // 2 count(3); // 3 count(); // 3  7.9 Always put default parameters last.\n// bad function handleThings(opts = {}, name) { // ... } // good function handleThings(name, opts = {}) { // ... }  7.10 Never use the Function constructor to create a new function. eslint: no-new-func\n Why? Creating a function in this way evaluates a string similarly to eval(), which opens vulnerabilities.\n // bad var add = new Function('a', 'b', 'return a + b'); // still bad var subtract = Function('a', 'b', 'return a - b');  7.11 Spacing in a function signature. eslint: space-before-function-paren space-before-blocks\n Why? Consistency is good, and you shouldn’t have to add or remove a space when adding or removing a name.\n // bad const f = function(){}; const g = function (){}; const h = function() {}; // good const x = function () {}; const y = function a() {};  7.12 Never mutate parameters. eslint: no-param-reassign\n Why? Manipulating objects passed in as parameters can cause unwanted variable side effects in the original caller.\n // bad function f1(obj) { obj.key = 1; } // good function f2(obj) { const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1; }  7.13 Never reassign parameters. eslint: no-param-reassign\n Why? Reassigning parameters can lead to unexpected behavior, especially when accessing the arguments object. It can also cause optimization issues, especially in V8.\n // bad function f1(a) { a = 1; // ... } function f2(a) { if (!a) { a = 1; } // ... } // good function f3(a) { const b = a || 1; // ... } function f4(a = 1) { // ... }  7.14 Prefer the use of the spread operator ... to call variadic functions. eslint: prefer-spread\n Why? It’s cleaner, you don’t need to supply a context, and you can not easily compose new with apply.\n // bad const x = [1, 2, 3, 4, 5]; console.log.apply(console, x); // good const x = [1, 2, 3, 4, 5]; console.log(...x); // bad new (Function.prototype.bind.apply(Date, [null, 2016, 8, 5])); // good new Date(...[2016, 8, 5]);  7.15 Functions with multiline signatures, or invocations, should be indented just like every other multiline list in this guide: with each item on a line by itself, with a trailing comma on the last item.\n// bad function foo(bar, baz, quux) { // ... } // good function foo( bar, baz, quux, ) { // ... } // bad console.log(foo, bar, baz); // good console.log( foo, bar, baz, );   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/arrow-functions/",
	"title": "Arrow Functions",
	"tags": [],
	"description": "",
	"content": " Arrow Functions  8.1 When you must use function expressions (as when passing an anonymous function), use arrow function notation. eslint: prefer-arrow-callback, arrow-spacing jscs: requireArrowFunctions\n Why? It creates a version of the function that executes in the context of this, which is usually what you want, and is a more concise syntax.\nWhy not? If you have a fairly complicated function, you might move that logic out into its own function declaration.\n // bad [1, 2, 3].map(function (x) { const y = x + 1; return x * y; }); // good [1, 2, 3].map((x) =\u0026gt; { const y = x + 1; return x * y; });  8.2 If the function body consists of a single statement returning an expression without side effects, omit the braces and use the implicit return. Otherwise, keep the braces and use a return statement. eslint: arrow-parens, arrow-body-style jscs: disallowParenthesesAroundArrowParam, requireShorthandArrowFunctions\n Why? Syntactic sugar. It reads well when multiple functions are chained together.\n // bad [1, 2, 3].map(number =\u0026gt; { const nextNumber = number + 1; `A string containing the ${nextNumber}.`; }); // good [1, 2, 3].map(number =\u0026gt; `A string containing the ${number}.`); // good [1, 2, 3].map((number) =\u0026gt; { const nextNumber = number + 1; return `A string containing the ${nextNumber}.`; }); // good [1, 2, 3].map((number, index) =\u0026gt; ({ [index]: number, })); // No implicit return with side effects function foo(callback) { const val = callback(); if (val === true) { // Do something if callback returns true } } let bool = false; // bad foo(() =\u0026gt; bool = true); // good foo(() =\u0026gt; { bool = true; });  8.3 In case the expression spans over multiple lines, wrap it in parentheses for better readability.\n Why? It shows clearly where the function starts and ends.\n // bad ['get', 'post', 'put'].map(httpMethod =\u0026gt; Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod, ) ); // good ['get', 'post', 'put'].map(httpMethod =\u0026gt; ( Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod, ) ));  8.4 If your function takes a single argument and doesn’t use braces, omit the parentheses. Otherwise, always include parentheses around arguments for clarity and consistency. Note: it is also acceptable to always use parentheses, in which case use the “always” option for eslint or do not include disallowParenthesesAroundArrowParam for jscs. eslint: arrow-parens jscs: disallowParenthesesAroundArrowParam\n Why? Less visual clutter.\n // bad [1, 2, 3].map((x) =\u0026gt; x * x); // good [1, 2, 3].map(x =\u0026gt; x * x); // good [1, 2, 3].map(number =\u0026gt; ( `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!` )); // bad [1, 2, 3].map(x =\u0026gt; { const y = x + 1; return x * y; }); // good [1, 2, 3].map((x) =\u0026gt; { const y = x + 1; return x * y; });  8.5 Avoid confusing arrow function syntax (=\u0026gt;) with comparison operators (\u0026lt;=, \u0026gt;=). eslint: no-confusing-arrow\n// bad const itemHeight = item =\u0026gt; item.height \u0026gt; 256 ? item.largeSize : item.smallSize; // bad const itemHeight = (item) =\u0026gt; item.height \u0026gt; 256 ? item.largeSize : item.smallSize; // good const itemHeight = item =\u0026gt; (item.height \u0026gt; 256 ? item.largeSize : item.smallSize); // good const itemHeight = (item) =\u0026gt; { const { height, largeSize, smallSize } = item; return height \u0026gt; 256 ? largeSize : smallSize; };   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/classes--constructors/",
	"title": "Classes &amp; Constructors",
	"tags": [],
	"description": "",
	"content": " Classes \u0026amp; Constructors  9.1 Always use class. Avoid manipulating prototype directly.\n Why? class syntax is more concise and easier to reason about.\n // bad function Queue(contents = []) { this.queue = [...contents]; } Queue.prototype.pop = function () { const value = this.queue[0]; this.queue.splice(0, 1); return value; }; // good class Queue { constructor(contents = []) { this.queue = [...contents]; } pop() { const value = this.queue[0]; this.queue.splice(0, 1); return value; } }  9.2 Use extends for inheritance.\n Why? It is a built-in way to inherit prototype functionality without breaking instanceof.\n // bad const inherits = require('inherits'); function PeekableQueue(contents) { Queue.apply(this, contents); } inherits(PeekableQueue, Queue); PeekableQueue.prototype.peek = function () { return this.queue[0]; }; // good class PeekableQueue extends Queue { peek() { return this.queue[0]; } }  9.3 Methods can return this to help with method chaining.\n// bad Jedi.prototype.jump = function () { this.jumping = true; return true; }; Jedi.prototype.setHeight = function (height) { this.height = height; }; const luke = new Jedi(); luke.jump(); // =\u0026gt; true luke.setHeight(20); // =\u0026gt; undefined // good class Jedi { jump() { this.jumping = true; return this; } setHeight(height) { this.height = height; return this; } } const luke = new Jedi(); luke.jump() .setHeight(20);  9.4 It’s okay to write a custom toString() method, just make sure it works successfully and causes no side effects.\nclass Jedi { constructor(options = {}) { this.name = options.name || 'no name'; } getName() { return this.name; } toString() { return `Jedi - ${this.getName()}`; } }  9.5 Classes have a default constructor if one is not specified. An empty constructor function or one that just delegates to a parent class is unnecessary. eslint: no-useless-constructor\n// bad class Jedi { constructor() {} getName() { return this.name; } } // bad class Rey extends Jedi { constructor(...args) { super(...args); } } // good class Rey extends Jedi { constructor(...args) { super(...args); this.name = 'Rey'; } }  9.6 Avoid duplicate class members. eslint: no-dupe-class-members\n Why? Duplicate class member declarations will silently prefer the last one - having duplicates is almost certainly a bug.\n // bad class Foo { bar() { return 1; } bar() { return 2; } } // good class Foo { bar() { return 1; } } // good class Foo { bar() { return 2; } }   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/modules/",
	"title": "Modules",
	"tags": [],
	"description": "",
	"content": " Modules  10.1 Always use modules (import/export) over a non-standard module system. You can always transpile to your preferred module system.\n Why? Modules are the future, let’s start using the future now.\n // bad const AirbnbStyleGuide = require('./AirbnbStyleGuide'); module.exports = AirbnbStyleGuide.es6; // ok import AirbnbStyleGuide from './AirbnbStyleGuide'; export default AirbnbStyleGuide.es6; // best import { es6 } from './AirbnbStyleGuide'; export default es6;  10.2 Do not use wildcard imports.\n Why? This makes sure you have a single default export.\n // bad import * as AirbnbStyleGuide from './AirbnbStyleGuide'; // good import AirbnbStyleGuide from './AirbnbStyleGuide';  10.3 And do not export directly from an import.\n Why? Although the one-liner is concise, having one clear way to import and one clear way to export makes things consistent.\n // bad // filename es6.js export { es6 as default } from './AirbnbStyleGuide'; // good // filename es6.js import { es6 } from './AirbnbStyleGuide'; export default es6;  10.4 Only import from a path in one place. eslint: no-duplicate-imports \u0026gt; Why? Having multiple lines that import from the same path can make code harder to maintain.\n// bad import foo from 'foo'; // … some other imports … // import { named1, named2 } from 'foo'; // good import foo, { named1, named2 } from 'foo'; // good import foo, { named1, named2, } from 'foo';  10.5 Do not export mutable bindings. eslint: import/no-mutable-exports \u0026gt; Why? Mutation should be avoided in general, but in particular when exporting mutable bindings. While this technique may be needed for some special cases, in general, only constant references should be exported.\n// bad let foo = 3; export { foo }; // good const foo = 3; export { foo };  10.6 In modules with a single export, prefer default export over named export. eslint: import/prefer-default-export\n// bad export function foo() {} // good export default function foo() {}  10.7 Put all imports above non-import statements. eslint: import/first \u0026gt; Why? Since imports are hoisted, keeping them all at the top prevents surprising behavior.\n// bad import foo from 'foo'; foo.init(); import bar from 'bar'; // good import foo from 'foo'; import bar from 'bar'; foo.init();  10.8 Multiline imports should be indented just like multiline array and object literals.\n Why? The curly braces follow the same indentation rules as every other curly brace block in the style guide, as do the trailing commas.\n // bad import {longNameA, longNameB, longNameC, longNameD, longNameE} from 'path'; // good import { longNameA, longNameB, longNameC, longNameD, longNameE, } from 'path';  10.9 Disallow Webpack loader syntax in module import statements. eslint: import/no-webpack-loader-syntax \u0026gt; Why? Since using Webpack syntax in the imports couples the code to a module bundler. Prefer using the loader syntax in webpack.config.js.\n// bad import fooSass from 'css!sass!foo.scss'; import barCss from 'style!css!bar.css'; // good import fooSass from 'foo.scss'; import barCss from 'bar.css';   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/iterators-and-generators/",
	"title": "Iterators And Generators",
	"tags": [],
	"description": "",
	"content": " Iterators and Generators  11.1 Don’t use iterators. Prefer JavaScript’s higher-order functions instead of loops like for-in or for-of. eslint: no-iterator no-restricted-syntax\n Why? This enforces our immutable rule. Dealing with pure functions that return values is easier to reason about than side effects.\nUse map() / every() / filter() / find() / findIndex() / reduce() / some() / \u0026hellip; to iterate over arrays, and Object.keys() / Object.values() / Object.entries() to produce arrays so you can iterate over objects.\n const numbers = [1, 2, 3, 4, 5]; // bad let sum = 0; for (let num of numbers) { sum += num; } sum === 15; // good let sum = 0; numbers.forEach((num) =\u0026gt; { sum += num; }); sum === 15; // best (use the functional force) const sum = numbers.reduce((total, num) =\u0026gt; total + num, 0); sum === 15; // bad const increasedByOne = []; for (let i = 0; i \u0026lt; numbers.length; i++) { increasedByOne.push(numbers[i] + 1); } // good const increasedByOne = []; numbers.forEach((num) =\u0026gt; { increasedByOne.push(num + 1); ); // best (keeping it functional) const increasedByOne = numbers.map(num =\u0026gt; num + 1);  11.2 Don’t use generators for now.\n Why? They don’t transpile well to ES5.\n 11.3 If you must use generators, or if you disregard our advice, make sure their function signature is spaced properly. eslint: generator-star-spacing\n Why? function and * are part of the same conceptual keyword - * is not a modifier for function, function* is a unique construct, different from function.\n // bad function * foo() { // ... } // bad const bar = function * () { // ... }; // bad const baz = function *() { // ... }; // bad const quux = function*() { // ... }; // bad function*foo() { // ... } // bad function *foo() { // ... } // very bad function * foo() { // ... } // very bad const wat = function * () { // ... }; // good function* foo() { // ... } // good const foo = function* () { // ... };   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/properties/",
	"title": "Properties",
	"tags": [],
	"description": "",
	"content": " Properties  12.1 Use dot notation when accessing properties. eslint: dot-notation jscs: requireDotNotation\nconst luke = { jedi: true, age: 28, }; // bad const isJedi = luke['jedi']; // good const isJedi = luke.jedi;  12.2 Use bracket notation [] when accessing properties with a variable.\nconst luke = { jedi: true, age: 28, }; function getProp(prop) { return luke[prop]; } const isJedi = getProp('jedi');   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/variables/",
	"title": "Variables",
	"tags": [],
	"description": "",
	"content": " Variables  13.1 Always use const or let to declare variables. Not doing so will result in global variables. We want to avoid polluting the global namespace. Captain Planet warned us of that. eslint: no-undef prefer-const\n// bad superPower = new SuperPower(); // good const superPower = new SuperPower();  13.2 Use one const or let declaration per variable. eslint: one-var jscs: disallowMultipleVarDecl\n Why? It’s easier to add new variable declarations this way, and you never have to worry about swapping out a ; for a , or introducing punctuation-only diffs. You can also step through each declaration with the debugger, instead of jumping through all of them at once.\n // bad const items = getItems(), goSportsTeam = true, dragonball = 'z'; // bad // (compare to above, and try to spot the mistake) const items = getItems(), goSportsTeam = true; dragonball = 'z'; // good const items = getItems(); const goSportsTeam = true; const dragonball = 'z';  13.3 Group all your consts and then group all your lets.\n Why? This is helpful when later on you might need to assign a variable depending on one of the previous assigned variables.\n // bad let i, len, dragonball, items = getItems(), goSportsTeam = true; // bad let i; const items = getItems(); let dragonball; const goSportsTeam = true; let len; // good const goSportsTeam = true; const items = getItems(); let dragonball; let i; let length;  13.4 Assign variables where you need them, but place them in a reasonable place.\n Why? let and const are block scoped and not function scoped.\n // bad - unnecessary function call function checkName(hasName) { const name = getName(); if (hasName === 'test') { return false; } if (name === 'test') { this.setName(''); return false; } return name; } // good function checkName(hasName) { if (hasName === 'test') { return false; } const name = getName(); if (name === 'test') { this.setName(''); return false; } return name; }  13.5 Don’t chain variable assignments.\n Why? Chaining variable assignments creates implicit global variables.\n // bad (function example() { // JavaScript interprets this as // let a = ( b = ( c = 1 ) ); // The let keyword only applies to variable a; variables b and c become // global variables. let a = b = c = 1; }()); console.log(a); // throws ReferenceError console.log(b); // 1 console.log(c); // 1 // good (function example() { let a = 1; let b = a; let c = a; }()); console.log(a); // throws ReferenceError console.log(b); // throws ReferenceError console.log(c); // throws ReferenceError // the same applies for `const`  13.6 Avoid using unary increments and decrements (++, \u0026ndash;). eslint no-plusplus\n Why? Per the eslint documentation, unary increment and decrement statements are subject to automatic semicolon insertion and can cause silent errors with incrementing or decrementing values within an application. It is also more expressive to mutate your values with statements like num += 1 instead of num++ or num ++. Disallowing unary increment and decrement statements also prevents you from pre-incrementing/pre-decrementing values unintentionally which can also cause unexpected behavior in your programs.\n // bad const array = [1, 2, 3]; let num = 1; num++; --num; let sum = 0; let truthyCount = 0; for (let i = 0; i \u0026lt; array.length; i++) { let value = array[i]; sum += value; if (value) { truthyCount++; } } // good const array = [1, 2, 3]; let num = 1; num += 1; num -= 1; const sum = array.reduce((a, b) =\u0026gt; a + b, 0); const truthyCount = array.filter(Boolean).length;   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/hoisting/",
	"title": "Hoisting",
	"tags": [],
	"description": "",
	"content": " Hoisting  14.1 var declarations get hoisted to the top of their scope, their assignment does not. const and let declarations are blessed with a new concept called Temporal Dead Zones (TDZ). It’s important to know why typeof is no longer safe.\n// we know this wouldn’t work (assuming there // is no notDefined global variable) function example() { console.log(notDefined); // =\u0026gt; throws a ReferenceError } // creating a variable declaration after you // reference the variable will work due to // variable hoisting. Note: the assignment // value of `true` is not hoisted. function example() { console.log(declaredButNotAssigned); // =\u0026gt; undefined var declaredButNotAssigned = true; } // the interpreter is hoisting the variable // declaration to the top of the scope, // which means our example could be rewritten as: function example() { let declaredButNotAssigned; console.log(declaredButNotAssigned); // =\u0026gt; undefined declaredButNotAssigned = true; } // using const and let function example() { console.log(declaredButNotAssigned); // =\u0026gt; throws a ReferenceError console.log(typeof declaredButNotAssigned); // =\u0026gt; throws a ReferenceError const declaredButNotAssigned = true; }  14.2 Anonymous function expressions hoist their variable name, but not the function assignment.\nfunction example() { console.log(anonymous); // =\u0026gt; undefined anonymous(); // =\u0026gt; TypeError anonymous is not a function var anonymous = function () { console.log('anonymous function expression'); }; }  14.3 Named function expressions hoist the variable name, not the function name or the function body.\nfunction example() { console.log(named); // =\u0026gt; undefined named(); // =\u0026gt; TypeError named is not a function superPower(); // =\u0026gt; ReferenceError superPower is not defined var named = function superPower() { console.log('Flying'); }; } // the same is true when the function name // is the same as the variable name. function example() { console.log(named); // =\u0026gt; undefined named(); // =\u0026gt; TypeError named is not a function var named = function named() { console.log('named'); }; }  14.4 Function declarations hoist their name and the function body.\nfunction example() { superPower(); // =\u0026gt; Flying function superPower() { console.log('Flying'); } }  For more information refer to JavaScript Scoping \u0026amp; Hoisting by Ben Cherry.\n  ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/comparison-operators--equality/",
	"title": "Comparison Operators &amp; Equality",
	"tags": [],
	"description": "",
	"content": " Comparison Operators \u0026amp; Equality  15.1 Use === and !== over == and !=. eslint: eqeqeq\n 15.2 Conditional statements such as the if statement evaluate their expression using coercion with the ToBoolean abstract method and always follow these simple rules:\n Objects evaluate to true Undefined evaluates to false Null evaluates to false Booleans evaluate to the value of the boolean Numbers evaluate to false if +0, -0, or NaN, otherwise true Strings evaluate to false if an empty string '', otherwise true  if ([0] \u0026amp;\u0026amp; []) { // true // an array (even an empty one) is an object, objects will evaluate to true }  15.3 Use shortcuts for booleans, but explicit comparisons for strings and numbers.\n// bad if (isValid === true) { // ... } // good if (isValid) { // ... } // bad if (name) { // ... } // good if (name !== '') { // ... } // bad if (collection.length) { // ... } // good if (collection.length \u0026gt; 0) { // ... }  15.4 For more information see Truth Equality and JavaScript by Angus Croll.\n 15.5 Use braces to create blocks in case and default clauses that contain lexical declarations (e.g. let, const, function, and class).\n Why? Lexical declarations are visible in the entire switch block but only get initialized when assigned, which only happens when its case is reached. This causes problems when multiple case clauses attempt to define the same thing.\n eslint rules: no-case-declarations.\n// bad switch (foo) { case 1: let x = 1; break; case 2: const y = 2; break; case 3: function f() { // ... } break; default: class C {} } // good switch (foo) { case 1: { let x = 1; break; } case 2: { const y = 2; break; } case 3: { function f() { // ... } break; } case 4: bar(); break; default: { class C {} } }  15.6 Ternaries should not be nested and generally be single line expressions.\neslint rules: no-nested-ternary.\n// bad const foo = maybe1 \u0026gt; maybe2 ? \u0026quot;bar\u0026quot; : value1 \u0026gt; value2 ? \u0026quot;baz\u0026quot; : null; // better const maybeNull = value1 \u0026gt; value2 ? 'baz' : null; const foo = maybe1 \u0026gt; maybe2 ? 'bar' : maybeNull; // best const maybeNull = value1 \u0026gt; value2 ? 'baz' : null; const foo = maybe1 \u0026gt; maybe2 ? 'bar' : maybeNull;  15.7 Avoid unneeded ternary statements.\neslint rules: no-unneeded-ternary.\n// bad const foo = a ? a : b; const bar = c ? true : false; const baz = c ? false : true; // good const foo = a || b; const bar = !!c; const baz = !c;   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/blocks/",
	"title": "Blocks",
	"tags": [],
	"description": "",
	"content": " Blocks  16.1 Use braces with all multi-line blocks.\n// bad if (test) return false; // good if (test) return false; // good if (test) { return false; } // bad function foo() { return false; } // good function bar() { return false; }  16.2 If you\u0026rsquo;re using multi-line blocks with if and else, put else on the same line as your if block’s closing brace. eslint: brace-style jscs: disallowNewlineBeforeBlockStatements\n// bad if (test) { thing1(); thing2(); } else { thing3(); } // good if (test) { thing1(); thing2(); } else { thing3(); }   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/control-statements/",
	"title": "Control Statements",
	"tags": [],
	"description": "",
	"content": " Control Statements  17.1 In case your control statement (if, while etc.) gets too long or exceeds the maximum line length, each (grouped) condition could be put into a new line. It’s up to you whether the logical operator should begin or end the line.\n// bad if ((foo === 123 || bar === 'abc') \u0026amp;\u0026amp; doesItLookGoodWhenItBecomesThatLong() \u0026amp;\u0026amp; isThisReallyHappening()) { thing1(); } // bad if (foo === 123 \u0026amp;\u0026amp; bar === 'abc') { thing1(); } // bad if (foo === 123 \u0026amp;\u0026amp; bar === 'abc') { thing1(); } // good if ( (foo === 123 || bar === \u0026quot;abc\u0026quot;) \u0026amp;\u0026amp; doesItLookGoodWhenItBecomesThatLong() \u0026amp;\u0026amp; isThisReallyHappening() ) { thing1(); } // good if (foo === 123 \u0026amp;\u0026amp; bar === 'abc') { thing1(); } // good if ( foo === 123 \u0026amp;\u0026amp; bar === 'abc' ) { thing1(); } // good if ( foo === 123 \u0026amp;\u0026amp; bar === 'abc' ) { thing1(); }   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/comments/",
	"title": "Comments",
	"tags": [],
	"description": "",
	"content": " Comments  18.1 Use /** ... */ for multi-line comments.  // bad // make() returns a new element // based on the passed in tag name // // @param {String} tag // @return {Element} element function make(tag) { // ... return element; } // good /** * make() returns a new element * based on the passed-in tag name */ function make(tag) { // ... return element; }   18.2 Use // for single line comments. Place single line comments on a newline above the subject of the comment. Put an empty line before the comment unless it’s on the first line of a block.\n// bad const active = true; // is current tab // good // is current tab const active = true; // bad function getType() { console.log('fetching type...'); // set the default type to 'no type' const type = this.type || 'no type'; return type; } // good function getType() { console.log('fetching type...'); // set the default type to 'no type' const type = this.type || 'no type'; return type; } // also good function getType() { // set the default type to 'no type' const type = this.type || 'no type'; return type; }  18.3 Start all comments with a space to make it easier to read. eslint: spaced-comment\n  // bad //is current tab const active = true; // good // is current tab const active = true; // bad /** *make() returns a new element *based on the passed-in tag name */ function make(tag) { // ... return element; } // good /** * make() returns a new element * based on the passed-in tag name */ function make(tag) { // ... return element; }   18.4 Prefixing your comments with FIXME or TODO helps other developers quickly understand if you\u0026rsquo;re pointing out a problem that needs to be revisited, or if you\u0026rsquo;re suggesting a solution to the problem that needs to be implemented. These are different than regular comments because they are actionable. The actions are FIXME: -- need to figure this out or TODO: -- need to implement.\n 18.5 Use // FIXME: to annotate problems.\nclass Calculator extends Abacus { constructor() { super(); // FIXME: shouldn’t use a global here total = 0; } }  18.6 Use // TODO: to annotate solutions to problems.\nclass Calculator extends Abacus { constructor() { super(); // TODO: total should be configurable by an options param this.total = 0; } }   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/whitespace/",
	"title": "Whitespace",
	"tags": [],
	"description": "",
	"content": " Whitespace  19.1 Use soft tabs (space character) set to 2 spaces. eslint: indent jscs: validateIndentation\n// bad function foo() { ∙∙∙∙let name; } // bad function bar() { ∙let name; } // good function baz() { ∙∙let name; }  19.2 Place 1 space before the leading brace. eslint: space-before-blocks jscs: requireSpaceBeforeBlockStatements\n// bad function test(){ console.log('test'); } // good function test() { console.log('test'); } // bad dog.set('attr',{ age: '1 year', breed: 'Bernese Mountain Dog', }); // good dog.set('attr', { age: '1 year', breed: 'Bernese Mountain Dog', });  19.3 Place 1 space before the opening parenthesis in control statements (if, while etc.). Place no space between the argument list and the function name in function calls and declarations. eslint: keyword-spacing jscs: requireSpaceAfterKeywords\n// bad if(isJedi) { fight (); } // good if (isJedi) { fight(); } // bad function fight () { console.log ('Swooosh!'); } // good function fight() { console.log('Swooosh!'); }  19.4 Set off operators with spaces. eslint: space-infix-ops jscs: requireSpaceBeforeBinaryOperators, requireSpaceAfterBinaryOperators\n// bad const x=y+5; // good const x = y + 5;  19.5 End files with a single newline character. eslint: eol-last\n// bad import { es6 } from './AirbnbStyleGuide'; // ... export default es6;  // bad import { es6 } from './AirbnbStyleGuide'; // ... export default es6;↵ ↵  // good import { es6 } from './AirbnbStyleGuide'; // ... export default es6;↵  19.6 Use indentation when making long method chains (more than 2 method chains). Use a leading dot, which emphasizes that the line is a method call, not a new statement. eslint: newline-per-chained-call no-whitespace-before-property\n// bad $('#items').find('.selected').highlight().end().find('.open').updateCount(); // bad $('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount(); // good $('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount(); // bad const leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', `translate(${radius + margin},${radius + margin})`) .call(tron.led); // good const leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', `translate(${radius + margin},${radius + margin})`) .call(tron.led); // good const leds = stage.selectAll('.led').data(data);  19.7 Leave a blank line after blocks and before the next statement. jscs: requirePaddingNewLinesAfterBlocks\n// bad if (foo) { return bar; } return baz; // good if (foo) { return bar; } return baz; // bad const obj = { foo() { }, bar() { }, }; return obj; // good const obj = { foo() { }, bar() { }, }; return obj; // bad const arr = [ function foo() { }, function bar() { }, ]; return arr; // good const arr = [ function foo() { }, function bar() { }, ]; return arr;  19.8 Do not pad your blocks with blank lines. eslint: padded-blocks jscs: disallowPaddingNewlinesInBlocks\n// bad function bar() { console.log(foo); } // also bad if (baz) { console.log(qux); } else { console.log(foo); } // good function bar() { console.log(foo); } // good if (baz) { console.log(qux); } else { console.log(foo); }  19.9 Do not add spaces inside parentheses. eslint: space-in-parens jscs: disallowSpacesInsideParentheses\n// bad function bar( foo ) { return foo; } // good function bar(foo) { return foo; } // bad if ( foo ) { console.log(foo); } // good if (foo) { console.log(foo); }  19.10 Do not add spaces inside brackets. eslint: array-bracket-spacing jscs: disallowSpacesInsideArrayBrackets\n// bad const foo = [ 1, 2, 3 ]; console.log(foo[ 0 ]); // good const foo = [1, 2, 3]; console.log(foo[0]);  19.11 Add spaces inside curly braces. eslint: object-curly-spacing jscs: requireSpacesInsideObjectBrackets\n// bad const foo = {clark: 'kent'}; // good const foo = { clark: 'kent' };  19.12 Avoid having lines of code that are longer than 100 characters (including whitespace). Note: per above, long strings are exempt from this rule, and should not be broken up. eslint: max-len jscs: maximumLineLength\n Why? This ensures readability and maintainability.\n // bad const foo = jsonData \u0026amp;\u0026amp; jsonData.foo \u0026amp;\u0026amp; jsonData.foo.bar \u0026amp;\u0026amp; jsonData.foo.bar.baz \u0026amp;\u0026amp; jsonData.foo.bar.baz.quux \u0026amp;\u0026amp; jsonData.foo.bar.baz.quux.xyzzy; // bad $.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' } }).done(() =\u0026gt; console.log('Congratulations!')).fail(() =\u0026gt; console.log('You have failed this city.')); // good const foo = jsonData \u0026amp;\u0026amp; jsonData.foo \u0026amp;\u0026amp; jsonData.foo.bar \u0026amp;\u0026amp; jsonData.foo.bar.baz \u0026amp;\u0026amp; jsonData.foo.bar.baz.quux \u0026amp;\u0026amp; jsonData.foo.bar.baz.quux.xyzzy; // good $.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' }, }) .done(() =\u0026gt; console.log('Congratulations!')) .fail(() =\u0026gt; console.log('You have failed this city.'));   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/commas/",
	"title": "Commas",
	"tags": [],
	"description": "",
	"content": " Commas  20.1 Leading commas: Nope. eslint: comma-style jscs: requireCommaBeforeLineBreak\n// bad const story = [ once , upon , aTime ]; // good const story = [ once, upon, aTime, ]; // bad const hero = { firstName: 'Ada' , lastName: 'Lovelace' , birthYear: 1815 , superPower: 'computers' }; // good const hero = { firstName: 'Ada', lastName: 'Lovelace', birthYear: 1815, superPower: 'computers', };  20.2 Additional trailing comma: Yup. eslint: comma-dangle jscs: requireTrailingComma\n Why? This leads to cleaner git diffs. Also, transpilers like Babel will remove the additional trailing comma in the transpiled code which means you don’t have to worry about the trailing comma problem in legacy browsers.\n  // bad - git diff without trailing comma const hero = { firstName: 'Florence', - lastName: 'Nightingale' + lastName: 'Nightingale', + inventorOf: ['coxcomb chart', 'modern nursing'] }; // good - git diff with trailing comma const hero = { firstName: 'Florence', lastName: 'Nightingale', + inventorOf: ['coxcomb chart', 'modern nursing'], };  // bad const hero = { firstName: 'Dana', lastName: 'Scully' }; const heroes = [ 'Batman', 'Superman' ]; // good const hero = { firstName: 'Dana', lastName: 'Scully', }; const heroes = [ 'Batman', 'Superman', ]; // bad function createHero( firstName, lastName, inventorOf ) { // does nothing } // good function createHero( firstName, lastName, inventorOf, ) { // does nothing } // good (note that a comma must not appear after a \u0026quot;rest\u0026quot; element) function createHero( firstName, lastName, inventorOf, ...heroArgs ) { // does nothing } // bad createHero( firstName, lastName, inventorOf ); // good createHero( firstName, lastName, inventorOf, ); // good (note that a comma must not appear after a \u0026quot;rest\u0026quot; element) createHero( firstName, lastName, inventorOf, ...heroArgs );  ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/semicolons/",
	"title": "Semicolons",
	"tags": [],
	"description": "",
	"content": " Semicolons  21.1 Yup. eslint: semi jscs: requireSemicolons\n// bad (function () { const name = 'Skywalker' return name })() // good (function () { const name = 'Skywalker'; return name; }()); // good, but legacy (guards against the function becoming an argument when two files with IIFEs are concatenated) ;((() =\u0026gt; { const name = 'Skywalker'; return name; })());  Read more.\n  ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/type-casting--coercion/",
	"title": "Type Casting &amp; Coercion",
	"tags": [],
	"description": "",
	"content": " Type Casting \u0026amp; Coercion  22.1 Perform type coercion at the beginning of the statement.\n 22.2 Strings:\n// =\u0026gt; this.reviewScore = 9; // bad const totalScore = this.reviewScore + ''; // invokes this.reviewScore.valueOf() // bad const totalScore = this.reviewScore.toString(); // isn’t guaranteed to return a string // good const totalScore = String(this.reviewScore);  22.3 Numbers: Use Number for type casting and parseInt always with a radix for parsing strings. eslint: radix\nconst inputValue = '4'; // bad const val = new Number(inputValue); // bad const val = +inputValue; // bad const val = inputValue \u0026gt;\u0026gt; 0; // bad const val = parseInt(inputValue); // good const val = Number(inputValue); // good const val = parseInt(inputValue, 10);  22.4 If for whatever reason you are doing something wild and parseInt is your bottleneck and need to use Bitshift for performance reasons, leave a comment explaining why and what you\u0026rsquo;re doing.\n  // good /** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */ const val = inputValue \u0026gt;\u0026gt; 0;   22.5 Note: Be careful when using bitshift operations. Numbers are represented as 64-bit values, but bitshift operations always return a 32-bit integer (source). Bitshift can lead to unexpected behavior for integer values larger than 32 bits. Discussion. Largest signed 32-bit Int is 2,147,483,647:\n2147483647 \u0026gt;\u0026gt; 0; // =\u0026gt; 2147483647 2147483648 \u0026gt;\u0026gt; 0; // =\u0026gt; -2147483648 2147483649 \u0026gt;\u0026gt; 0; // =\u0026gt; -2147483647  22.6 Booleans:\nconst age = 0; // bad const hasAge = new Boolean(age); // good const hasAge = Boolean(age); // best const hasAge = !!age;   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/naming-conventions/",
	"title": "Naming Conventions",
	"tags": [],
	"description": "",
	"content": " Naming Conventions  23.1 Avoid single letter names. Be descriptive with your naming. eslint: id-length\n// bad function q() { // ... } // good function query() { // ... }  23.2 Use camelCase when naming objects, functions, and instances. eslint: camelcase jscs: requireCamelCaseOrUpperCaseIdentifiers\n// bad const OBJEcttsssss = {}; const this_is_my_object = {}; function c() {} // good const thisIsMyObject = {}; function thisIsMyFunction() {}  23.3 Use PascalCase only when naming constructors or classes. eslint: new-cap jscs: requireCapitalizedConstructors\n// bad function user(options) { this.name = options.name; } const bad = new user({ name: 'nope', }); // good class User { constructor(options) { this.name = options.name; } } const good = new User({ name: 'yup', });  23.4 Do not use trailing or leading underscores. eslint: no-underscore-dangle jscs: disallowDanglingUnderscores\n Why? JavaScript does not have the concept of privacy in terms of properties or methods. Although a leading underscore is a common convention to mean “private”, in fact, these properties are fully public, and as such, are part of your public API contract. This convention might lead developers to wrongly think that a change won’t count as breaking, or that tests aren’t needed. tl;dr: if you want something to be “private”, it must not be observably present.\n // bad this.__firstName__ = 'Panda'; this.firstName_ = 'Panda'; this._firstName = 'Panda'; // good this.firstName = 'Panda';  23.5 Don’t save references to this. Use arrow functions or Function#bind. jscs: disallowNodeTypes\n// bad function foo() { const self = this; return function () { console.log(self); }; } // bad function foo() { const that = this; return function () { console.log(that); }; } // good function foo() { return () =\u0026gt; { console.log(this); }; }  23.6 A base filename should exactly match the name of its default export.\n// file 1 contents class CheckBox { // ... } export default CheckBox; // file 2 contents export default function fortyTwo() { return 42; } // file 3 contents export default function insideDirectory() {} // in some other file // bad import CheckBox from './checkBox'; // PascalCase import/export, camelCase filename import FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase export import InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export // bad import CheckBox from './check_box'; // PascalCase import/export, snake_case filename import forty_two from './forty_two'; // snake_case import/filename, camelCase export import inside_directory from './inside_directory'; // snake_case import, camelCase export import index from './inside_directory/index'; // requiring the index file explicitly import insideDirectory from './insideDirectory/index'; // requiring the index file explicitly // good import CheckBox from './CheckBox'; // PascalCase export/import/filename import fortyTwo from './fortyTwo'; // camelCase export/import/filename import insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit \u0026quot;index\u0026quot; // ^ supports both insideDirectory.js and insideDirectory/index.js  23.7 Use camelCase when you export-default a function. Your filename should be identical to your function’s name.\nfunction makeStyleGuide() { // ... } export default makeStyleGuide;  23.8 Use PascalCase when you export a constructor / class / singleton / function library / bare object.\nconst AirbnbStyleGuide = { es6: { }, }; export default AirbnbStyleGuide;  23.9 Acronyms and initialisms should always be all capitalized, or all lowercased.\n Why? Names are for readability, not to appease a computer algorithm.\n // bad import SmsContainer from './containers/SmsContainer'; // bad const HttpRequests = [ // ... ]; // good import SMSContainer from './containers/SMSContainer'; // good const HTTPRequests = [ // ... ]; // best import TextMessageContainer from './containers/TextMessageContainer'; // best const Requests = [ // ... ];   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/accessors/",
	"title": "Accessors",
	"tags": [],
	"description": "",
	"content": " Accessors  24.1 Accessor functions for properties are not required.\n 24.2 Do not use JavaScript getters/setters as they cause unexpected side effects and are harder to test, maintain, and reason about. Instead, if you do make accessor functions, use getVal() and setVal('hello').\n// bad class Dragon { get age() { // ... } set age(value) { // ... } } // good class Dragon { getAge() { // ... } setAge(value) { // ... } }  24.3 If the property/method is a boolean, use isVal() or hasVal().\n// bad if (!dragon.age()) { return false; } // good if (!dragon.hasAge()) { return false; }  24.4 It’s okay to create get() and set() functions, but be consistent.\nclass Jedi { constructor(options = {}) { const lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber); } set(key, val) { this[key] = val; } get(key) { return this[key]; } }   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/events/",
	"title": "Events",
	"tags": [],
	"description": "",
	"content": " Events  25.1 When attaching data payloads to events (whether DOM events or something more proprietary like Backbone events), pass a hash instead of a raw value. This allows a subsequent contributor to add more data to the event payload without finding and updating every handler for the event. For example, instead of:\n// bad $(this).trigger('listingUpdated', listing.id); // ... $(this).on('listingUpdated', (e, listingId) =\u0026gt; { // do something with listingId });  prefer:\n// good $(this).trigger('listingUpdated', { listingId: listing.id }); // ... $(this).on('listingUpdated', (e, data) =\u0026gt; { // do something with data.listingId });   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/jquery/",
	"title": "Jquery",
	"tags": [],
	"description": "",
	"content": " jQuery  26.1 Prefix jQuery object variables with a $. jscs: requireDollarBeforejQueryAssignment\n// bad const sidebar = $('.sidebar'); // good const $sidebar = $('.sidebar'); // good const $sidebarBtn = $('.sidebar-btn');  26.2 Cache jQuery lookups.\n// bad function setSidebar() { $('.sidebar').hide(); // ... $('.sidebar').css({ 'background-color': 'pink', }); } // good function setSidebar() { const $sidebar = $('.sidebar'); $sidebar.hide(); // ... $sidebar.css({ 'background-color': 'pink', }); }  26.3 For DOM queries use Cascading $('.sidebar ul') or parent \u0026gt; child $('.sidebar \u0026gt; ul'). jsPerf\n 26.4 Use find with scoped jQuery object queries.\n// bad $('ul', '.sidebar').hide(); // bad $('.sidebar').find('ul').hide(); // good $('.sidebar ul').hide(); // good $('.sidebar \u0026gt; ul').hide(); // good $sidebar.find('ul').hide();   ⬆ Back to Table of Contents\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/es6/ecmascript-6-es-2015-styles/",
	"title": "Ecmascript 6 Es 2015 Styles",
	"tags": [],
	"description": "",
	"content": " ECMAScript 6+ (ES 2015+) Styles  28.1 This is a collection of links to the various ES6 features.   Arrow Functions Classes Object Shorthand Object Concise Object Computed Properties Template Strings Destructuring Default Parameters Rest Array Spreads Let and Const Iterators and Generators Modules\n 28.2 Do not use TC39 proposals that have not reached stage 3.   Why? They are not finalized, and they are subject to change or to be withdrawn entirely. We want to use JavaScript, and proposals are not JavaScript yet.\n  ⬆ Back to Table of Contents\n} "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/testing/",
	"title": "Testing",
	"tags": [],
	"description": "",
	"content": " Testing  29.1 Yup.\nfunction foo() { return true; }  29.2 No, but seriously:\n Whichever testing framework you use, you should be writing tests! Strive to write many small pure functions, and minimize where mutations occur. Be cautious about stubs and mocks - they can make your tests more brittle. We primarily use mocha at Airbnb. tape is also used occasionally for small, separate modules. 100% test coverage is a good goal to strive for, even if it’s not always practical to reach it. Whenever you fix a bug, write a regression test. A bug fixed without a regression test is almost certainly going to break again in the future.   ⬆ Back \n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/performance/",
	"title": "Performance",
	"tags": [],
	"description": "",
	"content": " Performance  On Layout \u0026amp; Web Performance String vs Array Concat Try/Catch Cost In a Loop Bang Function jQuery Find vs Context, Selector innerHTML vs textContent for script text Long String Concatenation Are Javascript functions like map(), reduce(), and filter() optimized for traversing arrays? Loading\u0026hellip;  ⬆ Back \n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/resources/",
	"title": "Resources",
	"tags": [],
	"description": "",
	"content": " Resources Learning ES6\n Draft ECMA 2015 (ES6) Spec ExploringJS ES6 Compatibility Table Comprehensive Overview of ES6 Features  Read This\n Standard ECMA-262  Tools\n Code Style Linters  ESlint - Airbnb Style .eslintrc JSHint - Airbnb Style .jshintrc JSCS - Airbnb Style Preset (Deprecated, please use ESlint)  Neutrino preset - neutrino-preset-airbnb-base  Other Style Guides\n Google JavaScript Style Guide jQuery Core Style Guidelines Principles of Writing Consistent, Idiomatic JavaScript  Other Styles\n Naming this in nested functions - Christian Johansen Conditional Callbacks - Ross Allen Popular JavaScript Coding Conventions on GitHub - JeongHoon Byun Multiple var statements in JavaScript, not superfluous - Ben Alman  Further Reading\n Understanding JavaScript Closures - Angus Croll Basic JavaScript for the impatient programmer - Dr. Axel Rauschmayer You Might Not Need jQuery - Zack Bloom \u0026amp; Adam Schwartz ES6 Features - Luke Hoban Frontend Guidelines - Benjamin De Cock  Books\n JavaScript: The Good Parts - Douglas Crockford JavaScript Patterns - Stoyan Stefanov Pro JavaScript Design Patterns - Ross Harmes and Dustin Diaz High Performance Web Sites: Essential Knowledge for Front-End Engineers - Steve Souders Maintainable JavaScript - Nicholas C. Zakas JavaScript Web Applications - Alex MacCaw Pro JavaScript Techniques - John Resig Smashing Node.js: JavaScript Everywhere - Guillermo Rauch Secrets of the JavaScript Ninja - John Resig and Bear Bibeault Human JavaScript - Henrik Joreteg Superhero.js - Kim Joar Bekkelund, Mads Mobæk, \u0026amp; Olav Bjorkoy JSBooks - Julien Bouquillon Third Party JavaScript - Ben Vinegar and Anton Kovalyov Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript - David Herman Eloquent JavaScript - Marijn Haverbeke You Don’t Know JS: ES6 \u0026amp; Beyond - Kyle Simpson  Blogs\n JavaScript Weekly JavaScript, JavaScript\u0026hellip; Bocoup Weblog Adequately Good NCZOnline Perfection Kills Ben Alman Dmitry Baranovskiy Dustin Diaz nettuts  Podcasts\n JavaScript Air JavaScript Jabber  ⬆ Back \n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/in-the-wild/",
	"title": "In The Wild",
	"tags": [],
	"description": "",
	"content": " In the Wild This is a list of organizations that are using this style guide. Send us a pull request and we\u0026rsquo;ll add you to the list.\n 3blades: 3Blades/javascript 4Catalyzer: 4Catalyzer/javascript Aan Zee: AanZee/javascript Adult Swim: adult-swim/javascript Airbnb: airbnb/javascript AltSchool: AltSchool/javascript Apartmint: apartmint/javascript Ascribe: ascribe/javascript Avalara: avalara/javascript Avant: avantcredit/javascript Axept: axept/javascript BashPros: BashPros/javascript Billabong: billabong/javascript Bisk: bisk/javascript Bonhomme: bonhommeparis/javascript Brainshark: brainshark/javascript CaseNine: CaseNine/javascript Chartboost: ChartBoost/javascript-style-guide ComparaOnline: comparaonline/javascript Compass Learning: compasslearning/javascript-style-guide DailyMotion: dailymotion/javascript DoSomething: DoSomething/eslint-config Digitpaint digitpaint/javascript Ecosia: ecosia/javascript Evernote: evernote/javascript-style-guide Evolution Gaming: evolution-gaming/javascript EvozonJs: evozonjs/javascript ExactTarget: ExactTarget/javascript Expensify Expensify/Style-Guide Flexberry: Flexberry/javascript-style-guide Gawker Media: gawkermedia/javascript General Electric: GeneralElectric/javascript Generation Tux: GenerationTux/javascript GoodData: gooddata/gdc-js-style Grooveshark: grooveshark/javascript Honey: honeyscience/javascript How About We: howaboutwe/javascript Huballin: huballin/javascript HubSpot: HubSpot/javascript Hyper: hyperoslo/javascript-playbook InterCity Group: intercitygroup/javascript-style-guide Jam3: Jam3/Javascript-Code-Conventions JeopardyBot: kesne/jeopardy-bot JSSolutions: JSSolutions/javascript KickorStick: kickorstick/javascript Kinetica Solutions: kinetica/javascript Lonely Planet: lonelyplanet/javascript M2GEN: M2GEN/javascript Mighty Spring: mightyspring/javascript MinnPost: MinnPost/javascript MitocGroup: MitocGroup/javascript ModCloth: modcloth/javascript Money Advice Service: moneyadviceservice/javascript Muber: muber/javascript National Geographic: natgeo/javascript Nimbl3: nimbl3/javascript Nulogy: nulogy/javascript Orange Hill Development: orangehill/javascript Orion Health: orionhealth/javascript OutBoxSoft: OutBoxSoft/javascript Peerby: Peerby/javascript Razorfish: razorfish/javascript-style-guide reddit: reddit/styleguide/javascript React: facebook.github.io/react/contributing/how-to-contribute.html#style-guide REI: reidev/js-style-guide Ripple: ripple/javascript-style-guide SeekingAlpha: seekingalpha/javascript-style-guide Shutterfly: shutterfly/javascript Sourcetoad: sourcetoad/javascript Springload: springload/javascript StratoDem Analytics: stratodem/javascript SteelKiwi Development: steelkiwi/javascript StudentSphere: studentsphere/javascript SwoopApp: swoopapp/javascript SysGarage: sysgarage/javascript-style-guide Syzygy Warsaw: syzygypl/javascript Target: target/javascript TheLadders: TheLadders/javascript The Nerdery: thenerdery/javascript-standards T4R Technology: T4R-Technology/javascript VoxFeed: VoxFeed/javascript-style-guide WeBox Studio: weboxstudio/javascript Weggo: Weggo/javascript Zillow: zillow/javascript ZocDoc: ZocDoc/javascript  ⬆ Back \n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/javascript/the-javascript-style-guide-guide/",
	"title": "The Javascript Style Guide Guide",
	"tags": [],
	"description": "",
	"content": " The JavaScript Style Guide Guide  Reference  ⬆ Back \n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/meanjs/",
	"title": "MEAN Style Guide",
	"tags": [],
	"description": "",
	"content": " Introductions This document contains the guidelines and best practices for the frontend and backend web development team at Xcidic. This document is based on MEANJS framework.\nInclude  NodeJS Style Guide  "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/react/",
	"title": "React Style Guide",
	"tags": [],
	"description": "",
	"content": " Airbnb React/JSX Style Guide A mostly reasonable approach to React and JSX\nTable of Contents  Basic Rules Class vs React.createClass vs stateless Mixins Naming Declaration Alignment Quotes Spacing Props Refs Parentheses Tags Methods Ordering isMounted  "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/",
	"title": "Xcidic Coding Guidelines",
	"tags": [],
	"description": "",
	"content": " Xcidic Coding Guidelines Main Contents  AngularJS Style Guide JavaScript Style Guide MEANJS Style Guide ReactJS Style Guide  "
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/_header/",
	"title": "header",
	"tags": [],
	"description": "",
	"content": "Coding Guidelines Documentation\n"
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://xcidic.github.io/coding-guidelines/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]